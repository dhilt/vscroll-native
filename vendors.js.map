{"version":3,"file":"vendors.js","mappings":"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","sources":["webpack://vscroll-native/./node_modules/tslib/tslib.es6.js","webpack://vscroll-native/./node_modules/vscroll/src/classes/adapter/props.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/reactive.ts","webpack://vscroll-native/./node_modules/vscroll/src/inputs/common.ts","webpack://vscroll-native/./node_modules/vscroll/src/inputs/validation.ts","webpack://vscroll-native/./node_modules/vscroll/src/version.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/adapter/context.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/datasource.ts","webpack://vscroll-native/./node_modules/vscroll/src/inputs/datasource.ts","webpack://vscroll-native/./node_modules/vscroll/src/inputs/settings.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/misc/enums.ts","webpack://vscroll-native/./node_modules/vscroll/src/inputs/adapter.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/settings.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/misc/base.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/init.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/scroll.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/adapter/reset.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/adapter/reload.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/item.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/adapter/update.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/adapter/insert.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/adapter/append.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/adapter/check.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/adapter/remove.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/adapter/clip.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/adapter/replace.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/adapter/fix.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/start.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/preFetch.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/fetch.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/postFetch.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/render.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/end.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/adjust.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/preClip.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/clip.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/logger.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/domRoutines.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/paddings.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/viewport.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/buffer/defaultSize.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/buffer/cache.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/buffer/checkCall.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/buffer.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/state/cycle.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/state/fetch.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/state/clip.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/state/render.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/state/scroll.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/state.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/adapter.ts","webpack://vscroll-native/./node_modules/vscroll/src/scroller.ts","webpack://vscroll-native/./node_modules/vscroll/src/workflow.ts","webpack://vscroll-native/./node_modules/vscroll/src/workflow-transducer.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","import { Reactive } from '../reactive';\nimport {\n  IAdapterProp, IBufferInfo, ItemAdapter, IPackages, AdapterMethodResult, IReactivePropsStore\n} from '../../interfaces/index';\n\nexport enum AdapterPropName {\n  id = 'id',\n  mock = 'mock',\n  augmented = 'augmented',\n  version = 'version',\n  init = 'init',\n  init$ = 'init$',\n  packageInfo = 'packageInfo',\n  itemsCount = 'itemsCount',\n  bufferInfo = 'bufferInfo',\n  isLoading = 'isLoading',\n  isLoading$ = 'isLoading$',\n  loopPending = 'loopPending',\n  loopPending$ = 'loopPending$',\n  firstVisible = 'firstVisible',\n  firstVisible$ = 'firstVisible$',\n  lastVisible = 'lastVisible',\n  lastVisible$ = 'lastVisible$',\n  bof = 'bof',\n  bof$ = 'bof$',\n  eof = 'eof',\n  eof$ = 'eof$',\n  reset = 'reset',\n  reload = 'reload',\n  append = 'append',\n  prepend = 'prepend',\n  check = 'check',\n  remove = 'remove',\n  clip = 'clip',\n  insert = 'insert',\n  replace = 'replace',\n  update = 'update',\n  fix = 'fix',\n  relax = 'relax',\n  showLog = 'showLog',\n}\n\nexport enum AdapterPropType {\n  Scalar,\n  Reactive,\n  WorkflowRunner,\n  Function,\n}\n\nconst Name = AdapterPropName;\nconst Type = AdapterPropType;\n\nconst noop = () => null;\n\nexport const methodPreResult: AdapterMethodResult = {\n  immediate: true,\n  success: true,\n  details: 'Adapter is not initialized'\n};\n\nconst noopWF = () => Promise.resolve(methodPreResult);\n\nconst emptyPackageInfo: IPackages = {\n  core: {\n    name: '',\n    version: ''\n  },\n  consumer: {\n    name: '',\n    version: ''\n  }\n};\n\nconst bufferInfoDefault: IBufferInfo = {\n  firstIndex: NaN,\n  lastIndex: NaN,\n  minIndex: NaN,\n  maxIndex: NaN,\n  absMinIndex: -Infinity,\n  absMaxIndex: +Infinity,\n  defaultSize: NaN,\n};\n\nexport const EMPTY_ITEM = {\n  data: {},\n  element: {}\n} as ItemAdapter;\n\nexport const getDefaultAdapterProps = (): IAdapterProp[] => [\n  {\n    type: Type.Scalar,\n    name: Name.id,\n    value: 0,\n    permanent: true\n  },\n  {\n    type: Type.Scalar,\n    name: Name.mock,\n    value: true,\n    permanent: true\n  },\n  {\n    type: Type.Scalar,\n    name: Name.augmented,\n    value: false,\n    permanent: true\n  },\n  {\n    type: Type.Scalar,\n    name: Name.version,\n    value: '',\n    permanent: true\n  },\n  {\n    type: Type.Scalar,\n    name: Name.init,\n    value: false,\n    reactive: Name.init$\n  },\n  {\n    type: Type.Scalar,\n    name: Name.packageInfo,\n    value: emptyPackageInfo,\n    onDemand: true\n  },\n  {\n    type: Type.Scalar,\n    name: Name.itemsCount,\n    value: 0,\n    onDemand: true\n  },\n  {\n    type: Type.Scalar,\n    name: Name.bufferInfo,\n    value: bufferInfoDefault,\n    onDemand: true\n  },\n  {\n    type: Type.Scalar,\n    name: Name.isLoading,\n    value: false,\n    reactive: Name.isLoading$\n  },\n  {\n    type: Type.Scalar,\n    name: Name.loopPending,\n    value: false,\n    reactive: Name.loopPending$\n  },\n  {\n    type: Type.Scalar,\n    name: Name.firstVisible,\n    value: EMPTY_ITEM,\n    reactive: Name.firstVisible$,\n    wanted: true\n  },\n  {\n    type: Type.Scalar,\n    name: Name.lastVisible,\n    value: EMPTY_ITEM,\n    reactive: Name.lastVisible$,\n    wanted: true\n  },\n  {\n    type: Type.Scalar,\n    name: Name.bof,\n    value: false,\n    reactive: Name.bof$\n  },\n  {\n    type: Type.Scalar,\n    name: Name.eof,\n    value: false,\n    reactive: Name.eof$\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.reset,\n    value: noopWF\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.reload,\n    value: noopWF\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.append,\n    value: noopWF\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.prepend,\n    value: noopWF\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.check,\n    value: noopWF\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.remove,\n    value: noopWF\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.clip,\n    value: noopWF\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.insert,\n    value: noopWF\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.replace,\n    value: noopWF\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.update,\n    value: noopWF\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.fix,\n    value: noopWF\n  },\n  {\n    type: Type.Function,\n    name: Name.relax,\n    value: noop\n  },\n  {\n    type: Type.Function,\n    name: Name.showLog,\n    value: noop\n  },\n  {\n    type: Type.Reactive,\n    name: Name.init$,\n    value: new Reactive<boolean>()\n  },\n  {\n    type: Type.Reactive,\n    name: Name.isLoading$,\n    value: new Reactive<boolean>()\n  },\n  {\n    type: Type.Reactive,\n    name: Name.loopPending$,\n    value: new Reactive<boolean>()\n  },\n  {\n    type: Type.Reactive,\n    name: Name.firstVisible$,\n    value: new Reactive<ItemAdapter>(EMPTY_ITEM, { emitOnSubscribe: true })\n  },\n  {\n    type: Type.Reactive,\n    name: Name.lastVisible$,\n    value: new Reactive<ItemAdapter>(EMPTY_ITEM, { emitOnSubscribe: true })\n  },\n  {\n    type: Type.Reactive,\n    name: Name.bof$,\n    value: new Reactive<boolean>()\n  },\n  {\n    type: Type.Reactive,\n    name: Name.eof$,\n    value: new Reactive<boolean>()\n  }\n];\n\nexport const reactiveConfigStorage = new Map<number, IReactivePropsStore>();\n","type On<T> = (value: T) => void;\ntype Off = () => void;\n\ninterface Subscription<T> {\n  emit: On<T>;\n  off: Off;\n}\n\ninterface Options {\n  emitOnSubscribe?: boolean; // if set, emit right on subscribe (like rxjs BehaviorSubject)\n  emitEqual?: boolean; // if set, emit when new value is equal to the old one\n}\n\nexport class Reactive<T> {\n\n  private initialValue: T;\n  private value: T;\n  private id: number;\n  private options: Options;\n  private subscriptions: Map<number, Subscription<T>>;\n\n  constructor(value?: T, options?: Options) {\n    this.id = 0;\n    if (value !== void 0) {\n      this.value = value;\n      this.initialValue = value;\n    }\n    this.options = options || {};\n    this.subscriptions = new Map();\n  }\n\n  set(value: T): void {\n    if (this.value === value && !this.options.emitEqual) {\n      return;\n    }\n    this.value = value;\n    for (const [, sub] of this.subscriptions) {\n      sub.emit(value);\n      if (this.value !== value) {\n        break;\n      }\n    }\n  }\n\n  get(): T {\n    return this.value;\n  }\n\n  on(func: On<T>): Off {\n    const id = this.id++;\n    const subscription: Subscription<T> = {\n      emit: func,\n      off: () => {\n        subscription.emit = () => null;\n        this.subscriptions.delete(id);\n      }\n    };\n    this.subscriptions.set(id, subscription);\n    if (this.options.emitOnSubscribe) {\n      subscription.emit(this.value);\n    }\n    return () => subscription.off();\n  }\n\n  once(func: On<T>): Off {\n    const off = this.on(v => {\n      off();\n      func(v);\n    });\n    return off;\n  }\n\n  reset(): void {\n    this.set(this.initialValue);\n  }\n\n  dispose(): void {\n    this.subscriptions.forEach(sub => sub.off());\n  }\n}\n","export enum Direction {\n  forward = 'forward',\n  backward = 'backward'\n}\n\nexport enum SizeStrategy {\n  Average = 'average',\n  Constant = 'constant',\n  Frequent = 'frequent'\n}\n","import { IValidationContext } from '../interfaces/validation';\nimport {\n  IValidator,\n  ValidatedValue,\n  IValidatedData,\n  IValidatedCommonProps,\n  ICommonProps,\n  ICommonProp,\n} from '../interfaces/index';\n\nexport enum ValidatorType {\n  number = 'must be a number',\n  integer = 'must be an integer',\n  integerUnlimited = 'must be an integer or infinity',\n  moreOrEqual = 'must be a number greater than (or equal to) {arg1}',\n  itemList = 'must be an array of items {arg1}',\n  boolean = 'must be a boolean',\n  object = 'must be an object',\n  element = 'must be an html element',\n  function = 'must be a function',\n  funcOfxArguments = 'must have {arg1} argument(s)',\n  funcOfxAndMoreArguments = 'must have at least {arg1} argument(s)',\n  funcOfXToYArguments = 'must have {arg1} to {arg2} arguments',\n  oneOfCan = 'can be present as only one item of {arg1} list',\n  oneOfMust = 'must be present as only one item of {arg1} list',\n  or = 'must satisfy at least 1 validator from {arg1} list',\n  enum = 'must belong to {arg1} list',\n}\n\nconst getError = (msg: ValidatorType, args?: string[]) =>\n  (args || ['']).reduce((acc, arg, index) => acc.replace(`{arg${index + 1}}`, arg), msg);\n\nconst getNumber = (value: unknown): number =>\n  typeof value === 'number' || (typeof value === 'string' && value !== '')\n    ? Number(value)\n    : NaN;\n\nconst onNumber = (value: unknown): ValidatedValue => {\n  const parsedValue = getNumber(value);\n  const errors = [];\n  if (Number.isNaN(parsedValue)) {\n    errors.push(ValidatorType.number);\n  }\n  return { value: parsedValue, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onInteger = (value: unknown): ValidatedValue => {\n  const errors = [];\n  value = getNumber(value);\n  const parsedValue = parseInt(String(value), 10);\n  if (value !== parsedValue) {\n    errors.push(ValidatorType.integer);\n  }\n  return { value: parsedValue, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onIntegerUnlimited = (value: unknown): ValidatedValue => {\n  let parsedValue = value;\n  const errors = [];\n  value = getNumber(value);\n  if (!Number.isFinite(value)) {\n    parsedValue = value;\n  } else {\n    parsedValue = parseInt(String(value), 10);\n  }\n  if (value !== parsedValue) {\n    errors.push(ValidatorType.integerUnlimited);\n  }\n  return { value: parsedValue, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onMoreOrEqual = (limit: number, fallback?: boolean) => (value: unknown): ValidatedValue => {\n  const result = onNumber(value);\n  if (!result.isValid) {\n    return result;\n  }\n  let parsedValue = result.value as number;\n  const errors = [];\n  if (parsedValue < limit) {\n    if (!fallback) {\n      errors.push(getError(ValidatorType.moreOrEqual, [String(limit)]));\n    } else {\n      parsedValue = limit;\n    }\n  }\n  return { value: parsedValue, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onBoolean = (value: unknown): ValidatedValue => {\n  const errors = [];\n  let parsedValue = value;\n  if (value === 'true') {\n    parsedValue = true;\n  } else if (value === 'false') {\n    parsedValue = false;\n  }\n  if (typeof parsedValue !== 'boolean') {\n    errors.push(ValidatorType.boolean);\n  }\n  return { value: parsedValue, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onObject = (value: unknown): ValidatedValue => {\n  const errors = [];\n  if (Object.prototype.toString.call(value) !== '[object Object]') {\n    errors.push(ValidatorType.object);\n  }\n  return { value, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onHtmlElement = (value: unknown): ValidatedValue => {\n  const errors = [];\n  if (!(value instanceof Element) && !(value instanceof HTMLDocument)) {\n    errors.push(ValidatorType.element);\n  }\n  return { value, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onItemList = (value: unknown): ValidatedValue => {\n  let parsedValue = value;\n  const errors = [];\n  if (!Array.isArray(value)) {\n    errors.push(ValidatorType.itemList);\n    parsedValue = [];\n  } else if (!value.length) {\n    errors.push(getError(ValidatorType.itemList, ['with at least 1 item']));\n  } else if (value.length > 1) {\n    const type = typeof value[0];\n    for (let i = value.length - 1; i >= 0; i--) {\n      if (typeof value[i] !== type) {\n        errors.push(getError(ValidatorType.itemList, ['of items of the same type']));\n        break;\n      }\n    }\n  }\n  return { value: parsedValue as unknown[], isSet: true, isValid: !errors.length, errors };\n};\n\ntype Func = (...args: any[]) => void;\n\nconst onFunction = (value: unknown): ValidatedValue => {\n  const errors = [];\n  if (typeof value !== 'function') {\n    errors.push(ValidatorType.function);\n  }\n  return { value: value as Func, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onFunctionWithXArguments = (argsCount: number) => (value: unknown) => {\n  const result = onFunction(value);\n  if (!result.isValid) {\n    return result;\n  }\n  value = result.value;\n  const errors = [];\n  if ((value as Func).length !== argsCount) {\n    errors.push(getError(ValidatorType.funcOfxArguments, [String(argsCount)]));\n  }\n  return { value: value as Func, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onFunctionWithXAndMoreArguments = (argsCount: number) => (value: unknown): ValidatedValue => {\n  const result = onFunction(value);\n  if (!result.isValid) {\n    return result;\n  }\n  value = result.value;\n  const errors = [];\n  if ((value as Func).length < argsCount) {\n    errors.push(getError(ValidatorType.funcOfxArguments, [String(argsCount)]));\n  }\n  return { value: value as Func, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onFunctionWithXToYArguments = (from: number, to: number) => (value: unknown): ValidatedValue => {\n  const result = onFunction(value);\n  if (!result.isValid) {\n    return result;\n  }\n  value = result.value;\n  const errors = [];\n  if ((value as Func).length < from || (value as Func).length > to) {\n    errors.push(getError(ValidatorType.funcOfXToYArguments, [String(from), String(to)]));\n  }\n  return { value: value as Func, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onOneOf = (tokens: string[], must: boolean) => (value: unknown, context?: IValidationContext): ValidatedValue => {\n  const errors = [];\n  const isSet = value !== void 0;\n  let noOneIsPresent = !isSet;\n  const err = must ? ValidatorType.oneOfMust : ValidatorType.oneOfCan;\n  if (!Array.isArray(tokens) || !tokens.length) {\n    errors.push(getError(err, ['undefined']));\n  } else {\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      const token = tokens[i];\n      if (typeof token !== 'string') {\n        errors.push(getError(err, [tokens.join('\", \"')]) + ' (non-string token)');\n        break;\n      }\n      const isAnotherPresent = context && Object.prototype.hasOwnProperty.call(context, token);\n      if (isSet && isAnotherPresent) {\n        errors.push(getError(err, [tokens.join('\", \"')]) + ` (${token} is present)`);\n        break;\n      }\n      if (noOneIsPresent && isAnotherPresent) {\n        noOneIsPresent = false;\n      }\n    }\n    if (must && noOneIsPresent) {\n      errors.push(getError(err, [tokens.join('\", \"')]));\n    }\n  }\n  return { value, isSet, isValid: !errors.length, errors };\n};\n\nconst onOr = (validators: IValidator[]) => (value: unknown): ValidatedValue => {\n  const errors = [];\n  if (validators.every(validator => !validator.method(value).isValid)) {\n    errors.push(validators.map(v => v.type).join(' OR '));\n  }\n  return { value, isSet: true, isValid: !errors.length, errors };\n};\n\nenum AbstractEnum { }\ntype TEnum = typeof AbstractEnum;\n\nconst onEnum = (list: TEnum) => (value: unknown): ValidatedValue => {\n  const errors = [];\n  const values = Object.keys(list).filter(k => isNaN(Number(k))).map(k => list[k as unknown as number]);\n  if (!values.some(item => item === value)) {\n    errors.push(getError(ValidatorType.enum, ['[' + values.join(',') + ']']));\n  }\n  return { value, isSet: true, isValid: !errors.length, errors };\n};\n\nexport const VALIDATORS = {\n  NUMBER: {\n    type: ValidatorType.number,\n    method: onNumber\n  },\n  INTEGER: {\n    type: ValidatorType.integer,\n    method: onInteger\n  },\n  INTEGER_UNLIMITED: {\n    type: ValidatorType.integerUnlimited,\n    method: onIntegerUnlimited\n  },\n  MORE_OR_EQUAL: (limit: number, fallback?: boolean): IValidator => ({\n    type: ValidatorType.moreOrEqual,\n    method: onMoreOrEqual(limit, fallback)\n  }),\n  BOOLEAN: {\n    type: ValidatorType.boolean,\n    method: onBoolean\n  },\n  OBJECT: {\n    type: ValidatorType.object,\n    method: onObject\n  },\n  ITEM_LIST: {\n    type: ValidatorType.itemList,\n    method: onItemList\n  },\n  ELEMENT: {\n    type: ValidatorType.element,\n    method: onHtmlElement\n  },\n  FUNC: {\n    type: ValidatorType.function,\n    method: onFunction\n  },\n  FUNC_WITH_X_ARGUMENTS: (count: number): IValidator => ({\n    type: ValidatorType.funcOfxArguments,\n    method: onFunctionWithXArguments(count)\n  }),\n  FUNC_WITH_X_AND_MORE_ARGUMENTS: (count: number): IValidator => ({\n    type: ValidatorType.funcOfxAndMoreArguments,\n    method: onFunctionWithXAndMoreArguments(count)\n  }),\n  FUNC_WITH_X_TO_Y_ARGUMENTS: (from: number, to: number): IValidator => ({\n    type: ValidatorType.funcOfXToYArguments,\n    method: onFunctionWithXToYArguments(from, to)\n  }),\n  ONE_OF_CAN: (list: string[]): IValidator => ({\n    type: ValidatorType.oneOfCan,\n    method: onOneOf(list, false)\n  }),\n  ONE_OF_MUST: (list: string[]): IValidator => ({\n    type: ValidatorType.oneOfMust,\n    method: onOneOf(list, true)\n  }),\n  OR: (list: IValidator[]): IValidator => ({\n    type: ValidatorType.or,\n    method: onOr(list)\n  }),\n  ENUM: (list: TEnum): IValidator => ({\n    type: ValidatorType.enum,\n    method: onEnum(list)\n  })\n};\n\nexport class ValidatedData implements IValidatedData {\n\n  context: IValidationContext;\n  isValidContext: boolean;\n  isValid: boolean;\n  errors: string[];\n  params: IValidatedCommonProps<PropertyKey>;\n\n  private contextErrors: string[];\n\n  constructor(context: unknown) {\n    this.params = {};\n    this.contextErrors = [];\n    this.errors = [];\n    this.isValid = true;\n    this.setContext(context);\n  }\n\n  private setContext(context: unknown): void {\n    if (!context || Object.prototype.toString.call(context) !== '[object Object]') {\n      this.setCommonError('context is not an object');\n      this.isValidContext = false;\n    } else {\n      this.isValidContext = true;\n    }\n    this.context = context as IValidationContext;\n  }\n\n  private setValidity() {\n    this.errors = Object.keys(this.params).reduce((acc: string[], key: string) => [\n      ...acc, ...this.params[key].errors\n    ], []);\n    this.isValid = !this.errors.length;\n  }\n\n  setCommonError(error: string): void {\n    this.contextErrors.push(error);\n    this.errors.push(error);\n    this.isValid = false;\n  }\n\n  setParam(token: string, value: ValidatedValue): void {\n    if (!value.isValid) {\n      value.errors = !value.isSet\n        ? [`\"${token}\" must be set`]\n        : value.errors.map((err: string) =>\n          `\"${token}\" ${err}`\n        );\n    }\n    this.params[token] = value;\n    this.setValidity();\n  }\n\n  showErrors(): string {\n    return this.errors.length\n      ? 'validation failed: ' + this.errors.join(', ')\n      : '';\n  }\n}\n\nexport const runValidator = (\n  current: ValidatedValue,\n  validator: IValidator,\n  context: IValidationContext\n): ValidatedValue => {\n  const { value, errors } = current;\n  const result = validator.method(value, context);\n  const _errors = [...errors, ...result.errors];\n  return {\n    value: result.value,\n    isSet: result.isSet,\n    isValid: !_errors.length,\n    errors: _errors\n  };\n};\n\nconst getDefault = (value: unknown, prop: ICommonProp): ValidatedValue => {\n  const empty = value === void 0;\n  const auto = !prop.mandatory && prop.defaultValue !== void 0;\n  return {\n    value: !empty ? value : (auto ? prop.defaultValue : void 0),\n    isSet: !empty || auto,\n    isValid: !empty || !prop.mandatory,\n    errors: []\n  };\n};\n\nexport const validateOne = (\n  context: IValidationContext, name: string, prop: ICommonProp\n): ValidatedValue => {\n  const result = getDefault(context[name], prop);\n  if (!result.isSet) {\n    const oneOfMust = prop.validators.find(v => v.type === ValidatorType.oneOfMust);\n    if (oneOfMust) {\n      return runValidator(result, oneOfMust, context);\n    }\n  } else {\n    for (const validator of Object.values(prop.validators)) {\n      const current = runValidator(result, validator, context);\n      if (!current.isValid && prop.defaultValue !== void 0) {\n        return {\n          value: prop.defaultValue,\n          isSet: true,\n          isValid: true,\n          errors: []\n        };\n      }\n      Object.assign(result, current);\n    }\n  }\n  return result;\n};\n\nexport const validate = (\n  context: unknown, params: ICommonProps<PropertyKey>\n): IValidatedData => {\n  const data = new ValidatedData(context);\n  Object.entries(params).forEach(([key, prop]) =>\n    data.setParam(key, data.isValidContext\n      ? validateOne(data.context, key, prop)\n      : getDefault(void 0, prop)\n    )\n  );\n  return data;\n};\n","export default {\n  name: 'vscroll',\n  version: '1.5.0'\n};\n","import { AdapterPropName, AdapterPropType, getDefaultAdapterProps, reactiveConfigStorage } from './props';\nimport core from '../../version';\nimport { Reactive } from '../reactive';\nimport { IReactivePropsStore, IAdapterConfig } from '../../interfaces/index';\n\nlet instanceCount = 0;\n\nexport class AdapterContext {\n\n  constructor(config: IAdapterConfig) {\n    const { mock, reactive } = config;\n    const id = ++instanceCount;\n    const conf = { configurable: true };\n    const reactivePropsStore: IReactivePropsStore = {};\n\n    // set up permanent props\n    Object.defineProperty(this, AdapterPropName.id, { get: () => id, ...conf });\n    Object.defineProperty(this, AdapterPropName.mock, { get: () => mock, ...conf });\n    Object.defineProperty(this, AdapterPropName.augmented, { get: () => false, ...conf });\n    Object.defineProperty(this, AdapterPropName.version, { get: () => core.version, ...conf });\n\n    // set up default props, they will be reassigned during the Adapter instantiation\n    getDefaultAdapterProps()\n      .filter(({ permanent }) => !permanent)\n      .forEach(({ name, value, type }) => {\n\n        // reactive props might be reconfigured by the vscroll consumer\n        if (reactive && type === AdapterPropType.Reactive) {\n          const react = reactive[name];\n          if (react) {\n            // here we have a configured reactive property that came from the outer config\n            // this prop must be exposed via Adapter, but at the same time we need to\n            // persist the original default value as it will be used by the Adapter internally\n            reactivePropsStore[name] = {\n              ...react,\n              default: value as Reactive<unknown> // persisting the default native Reactive prop\n            };\n            value = react.source; // exposing the configured prop instead of the default one\n          }\n        }\n\n        Object.defineProperty(this, name, {\n          get: () => value,\n          ...conf\n        });\n      });\n\n    if (reactive) { // save both configured and default reactive props in the store\n      reactiveConfigStorage.set(id, reactivePropsStore);\n    }\n  }\n}\n","import { AdapterContext } from './adapter/context';\r\nimport { reactiveConfigStorage } from './adapter/props';\r\nimport {\r\n  IDatasource,\r\n  IDatasourceConstructed,\r\n  DatasourceGet,\r\n  Settings,\r\n  DevSettings,\r\n  IAdapter,\r\n  IAdapterConfig,\r\n} from '../interfaces/index';\r\n\r\nexport class DatasourceGeneric<Data> implements IDatasourceConstructed<Data> {\r\n  get: DatasourceGet<Data>;\r\n  settings?: Settings<Data>;\r\n  devSettings?: DevSettings;\r\n  adapter: IAdapter<Data>;\r\n\r\n  constructor(datasource: IDatasource<Data>, config?: IAdapterConfig) {\r\n    this.get = datasource.get;\r\n    if (datasource.settings) {\r\n      this.settings = datasource.settings;\r\n    }\r\n    if (datasource.devSettings) {\r\n      this.devSettings = datasource.devSettings;\r\n    }\r\n    const adapterContext = new AdapterContext(config || { mock: false });\r\n    this.adapter = adapterContext as IAdapter<Data>;\r\n  }\r\n\r\n  dispose(): void { // todo: should it be published?\r\n    reactiveConfigStorage.delete(this.adapter.id);\r\n  }\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\nexport const makeDatasource = (getConfig?: () => IAdapterConfig) =>\r\n  class <Data = unknown> extends DatasourceGeneric<Data> {\r\n    constructor(datasource: IDatasource<Data>) {\r\n      const config = typeof getConfig === 'function' ? getConfig() : void 0;\r\n      super(datasource, config);\r\n    }\r\n  };\r\n\r\nexport const Datasource = makeDatasource();\r\n","import { VALIDATORS } from './validation';\nimport { ICommonProps } from '../interfaces/index';\n\nconst { OBJECT, FUNC_WITH_X_AND_MORE_ARGUMENTS } = VALIDATORS;\n\nexport enum DatasourceProps {\n  get = 'get',\n  settings = 'settings',\n  devSettings = 'devSettings',\n}\n\nexport const DATASOURCE: ICommonProps<DatasourceProps> = {\n  [DatasourceProps.get]: {\n    validators: [FUNC_WITH_X_AND_MORE_ARGUMENTS(2)],\n    mandatory: true\n  },\n  [DatasourceProps.settings]: {\n    validators: [OBJECT]\n  },\n  [DatasourceProps.devSettings]: {\n    validators: [OBJECT]\n  }\n};\n","import { VALIDATORS } from './validation';\nimport { ICommonProps } from '../interfaces/index';\nimport { SizeStrategy, Direction } from './common';\n\nconst { NUMBER, INTEGER, INTEGER_UNLIMITED, MORE_OR_EQUAL, BOOLEAN, ELEMENT, FUNC, OR, ENUM } = VALIDATORS;\n\nenum Settings {\n  adapter = 'adapter',\n  startIndex = 'startIndex',\n  minIndex = 'minIndex',\n  maxIndex = 'maxIndex',\n  itemSize = 'itemSize',\n  bufferSize = 'bufferSize',\n  padding = 'padding',\n  infinite = 'infinite',\n  horizontal = 'horizontal',\n  windowViewport = 'windowViewport',\n  viewportElement = 'viewportElement',\n  inverse = 'inverse',\n  onBeforeClip = 'onBeforeClip',\n  sizeStrategy = 'sizeStrategy',\n}\n\nenum DevSettings {\n  debug = 'debug',\n  immediateLog = 'immediateLog',\n  logProcessRun = 'logProcessRun',\n  logTime = 'logTime',\n  throttle = 'throttle',\n  initDelay = 'initDelay',\n  initWindowDelay = 'initWindowDelay',\n  cacheData = 'cacheData',\n  cacheOnReload = 'cacheOnReload',\n  dismissOverflowAnchor = 'dismissOverflowAnchor',\n  directionPriority = 'directionPriority',\n}\n\nexport const MIN = {\n  [Settings.itemSize]: 1,\n  [Settings.bufferSize]: 1,\n  [Settings.padding]: 0.01,\n  [DevSettings.throttle]: 0,\n  [DevSettings.initDelay]: 0,\n  [DevSettings.initWindowDelay]: 0,\n};\n\nexport const SETTINGS: ICommonProps<Settings> = {\n  [Settings.adapter]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [Settings.startIndex]: {\n    validators: [INTEGER],\n    defaultValue: 1\n  },\n  [Settings.minIndex]: {\n    validators: [INTEGER_UNLIMITED],\n    defaultValue: -Infinity\n  },\n  [Settings.maxIndex]: {\n    validators: [INTEGER_UNLIMITED],\n    defaultValue: Infinity\n  },\n  [Settings.itemSize]: {\n    validators: [INTEGER, MORE_OR_EQUAL(MIN[Settings.itemSize], true)],\n    defaultValue: NaN\n  },\n  [Settings.bufferSize]: {\n    validators: [INTEGER, MORE_OR_EQUAL(MIN[Settings.bufferSize], true)],\n    defaultValue: 5\n  },\n  [Settings.padding]: {\n    validators: [NUMBER, MORE_OR_EQUAL(MIN[Settings.padding], true)],\n    defaultValue: 0.5\n  },\n  [Settings.infinite]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [Settings.horizontal]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [Settings.windowViewport]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [Settings.viewportElement]: {\n    validators: [OR([ELEMENT, FUNC])],\n    defaultValue: null\n  },\n  [Settings.inverse]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [Settings.onBeforeClip]: {\n    validators: [FUNC],\n    defaultValue: null\n  },\n  [Settings.sizeStrategy]: {\n    validators: [ENUM(SizeStrategy)],\n    defaultValue: SizeStrategy.Average\n  },\n};\n\nexport const DEV_SETTINGS: ICommonProps<DevSettings> = {\n  [DevSettings.debug]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [DevSettings.immediateLog]: {\n    validators: [BOOLEAN],\n    defaultValue: true\n  },\n  [DevSettings.logProcessRun]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [DevSettings.logTime]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [DevSettings.throttle]: {\n    validators: [INTEGER, MORE_OR_EQUAL(MIN[DevSettings.throttle], true)],\n    defaultValue: 40\n  },\n  [DevSettings.initDelay]: {\n    validators: [INTEGER, MORE_OR_EQUAL(MIN[DevSettings.initDelay], true)],\n    defaultValue: 1\n  },\n  [DevSettings.initWindowDelay]: {\n    validators: [INTEGER, MORE_OR_EQUAL(MIN[DevSettings.initWindowDelay], true)],\n    defaultValue: 40\n  },\n  [DevSettings.cacheData]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [DevSettings.cacheOnReload]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [DevSettings.dismissOverflowAnchor]: {\n    validators: [BOOLEAN],\n    defaultValue: true\n  },\n  [DevSettings.directionPriority]: {\n    validators: [ENUM(Direction)],\n    defaultValue: Direction.backward\n  },\n};\n","export enum CommonProcess {\n  init = 'init',\n  scroll = 'scroll',\n  start = 'start',\n  preFetch = 'preFetch',\n  fetch = 'fetch',\n  postFetch = 'postFetch',\n  render = 'render',\n  preClip = 'preClip',\n  clip = 'clip',\n  adjust = 'adjust',\n  end = 'end',\n}\n\nexport enum AdapterProcess {\n  reset = 'adapter.reset',\n  reload = 'adapter.reload',\n  append = 'adapter.append',\n  prepend = 'adapter.prepend',\n  check = 'adapter.check',\n  remove = 'adapter.remove',\n  replace = 'adapter.replace',\n  update = 'adapter.update',\n  clip = 'adapter.clip',\n  insert = 'adapter.insert',\n  fix = 'adapter.fix',\n}\n\nexport enum ProcessStatus {\n  start = 'start',\n  next = 'next',\n  done = 'done',\n  error = 'error'\n}\n","import { VALIDATORS } from './validation';\nimport { DatasourceProps as AdapterResetParams } from './datasource';\nimport { AdapterProcess as Process } from '../processes/misc/enums';\nimport { ICommonProps, AdapterProcessMap } from '../interfaces/index';\n\nconst {\n  INTEGER,\n  INTEGER_UNLIMITED,\n  BOOLEAN,\n  OBJECT,\n  ITEM_LIST,\n  FUNC_WITH_X_ARGUMENTS,\n  FUNC_WITH_X_AND_MORE_ARGUMENTS,\n  FUNC_WITH_X_TO_Y_ARGUMENTS,\n  ONE_OF_MUST,\n  ONE_OF_CAN,\n  OR,\n} = VALIDATORS;\n\nenum AdapterNoParams { }\nconst NO_METHOD_PARAMS: ICommonProps<AdapterNoParams> = {};\n\nconst RESET_METHOD_PARAMS: ICommonProps<AdapterResetParams> = {\n  [AdapterResetParams.get]: {\n    validators: [FUNC_WITH_X_AND_MORE_ARGUMENTS(2)]\n  },\n  [AdapterResetParams.settings]: {\n    validators: [OBJECT]\n  },\n  [AdapterResetParams.devSettings]: {\n    validators: [OBJECT]\n  },\n};\n\nenum AdapterReloadParams {\n  reloadIndex = 'reloadIndex',\n}\n\nconst RELOAD_METHOD_PARAMS: ICommonProps<AdapterReloadParams> = {\n  [AdapterReloadParams.reloadIndex]: {\n    validators: [INTEGER]\n  },\n};\n\nenum AdapterPrependParams {\n  items = 'items',\n  bof = 'bof',\n  increase = 'increase',\n}\n\nconst PREPEND_METHOD_PARAMS: ICommonProps<AdapterPrependParams> = {\n  [AdapterPrependParams.items]: {\n    validators: [ITEM_LIST],\n    mandatory: true\n  },\n  [AdapterPrependParams.bof]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [AdapterPrependParams.increase]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n};\n\nenum AdapterAppendParams {\n  items = 'items',\n  eof = 'eof',\n  decrease = 'decrease',\n}\n\nconst APPEND_METHOD_PARAMS: ICommonProps<AdapterAppendParams> = {\n  [AdapterAppendParams.items]: {\n    validators: [ITEM_LIST],\n    mandatory: true\n  },\n  [AdapterAppendParams.eof]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [AdapterAppendParams.decrease]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n};\n\nenum AdapterRemoveParams {\n  predicate = 'predicate',\n  indexes = 'indexes',\n  increase = 'increase',\n}\n\nconst REMOVE_METHOD_PARAMS: ICommonProps<AdapterRemoveParams> = {\n  [AdapterRemoveParams.predicate]: {\n    validators: [FUNC_WITH_X_ARGUMENTS(1), ONE_OF_MUST([AdapterRemoveParams.indexes])]\n  },\n  [AdapterRemoveParams.indexes]: {\n    validators: [ITEM_LIST, ONE_OF_MUST([AdapterRemoveParams.predicate])]\n  },\n  [AdapterRemoveParams.increase]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n};\n\nenum AdapterClipParams {\n  backwardOnly = 'backwardOnly',\n  forwardOnly = 'forwardOnly',\n}\n\nconst CLIP_METHOD_PARAMS: ICommonProps<AdapterClipParams> = {\n  [AdapterClipParams.backwardOnly]: {\n    validators: [BOOLEAN, ONE_OF_CAN([AdapterClipParams.forwardOnly])],\n    defaultValue: false\n  },\n  [AdapterClipParams.forwardOnly]: {\n    validators: [BOOLEAN, ONE_OF_CAN([AdapterClipParams.backwardOnly])],\n    defaultValue: false\n  },\n};\n\nenum AdapterInsertParams {\n  items = 'items',\n  before = 'before',\n  after = 'after',\n  beforeIndex = 'beforeIndex',\n  afterIndex = 'afterIndex',\n  decrease = 'decrease',\n}\n\nconst INSERT_METHOD_PARAMS: ICommonProps<AdapterInsertParams> = {\n  [AdapterInsertParams.items]: {\n    validators: [ITEM_LIST],\n    mandatory: true\n  },\n  [AdapterInsertParams.before]: {\n    validators: [FUNC_WITH_X_ARGUMENTS(1), ONE_OF_MUST([\n      AdapterInsertParams.after, AdapterInsertParams.beforeIndex, AdapterInsertParams.afterIndex\n    ])]\n  },\n  [AdapterInsertParams.after]: {\n    validators: [FUNC_WITH_X_ARGUMENTS(1), ONE_OF_MUST([\n      AdapterInsertParams.before, AdapterInsertParams.beforeIndex, AdapterInsertParams.afterIndex\n    ])]\n  },\n  [AdapterInsertParams.beforeIndex]: {\n    validators: [INTEGER, ONE_OF_MUST([\n      AdapterInsertParams.before, AdapterInsertParams.after, AdapterInsertParams.afterIndex\n    ])]\n  },\n  [AdapterInsertParams.afterIndex]: {\n    validators: [INTEGER, ONE_OF_MUST([\n      AdapterInsertParams.before, AdapterInsertParams.after, AdapterInsertParams.beforeIndex\n    ])]\n  },\n  [AdapterInsertParams.decrease]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n};\n\nenum AdapterReplaceParams {\n  items = 'items',\n  predicate = 'predicate',\n  fixRight = 'fixRight',\n}\n\nconst REPLACE_METHOD_PARAMS: ICommonProps<AdapterReplaceParams> = {\n  [AdapterInsertParams.items]: {\n    validators: [ITEM_LIST],\n    mandatory: true\n  },\n  [AdapterReplaceParams.predicate]: {\n    validators: [FUNC_WITH_X_ARGUMENTS(1)],\n    mandatory: true\n  },\n  [AdapterReplaceParams.fixRight]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  }\n};\n\nenum AdapterUpdateParams {\n  predicate = 'predicate',\n  fixRight = 'fixRight',\n}\n\nconst UPDATE_METHOD_PARAMS: ICommonProps<AdapterUpdateParams> = {\n  [AdapterUpdateParams.predicate]: {\n    validators: [FUNC_WITH_X_ARGUMENTS(1)],\n    mandatory: true\n  },\n  [AdapterUpdateParams.fixRight]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n};\n\nenum AdapterFixParams {\n  scrollPosition = 'scrollPosition',\n  minIndex = 'minIndex',\n  maxIndex = 'maxIndex',\n  updater = 'updater',\n  scrollToItem = 'scrollToItem',\n  scrollToItemOpt = 'scrollToItemOpt',\n}\n\nconst FIX_METHOD_PARAMS: ICommonProps<AdapterFixParams> = {\n  [AdapterFixParams.scrollPosition]: {\n    validators: [INTEGER_UNLIMITED]\n  },\n  [AdapterFixParams.minIndex]: {\n    validators: [INTEGER_UNLIMITED]\n  },\n  [AdapterFixParams.maxIndex]: {\n    validators: [INTEGER_UNLIMITED]\n  },\n  [AdapterFixParams.updater]: {\n    validators: [FUNC_WITH_X_TO_Y_ARGUMENTS(1, 2)]\n  },\n  [AdapterFixParams.scrollToItem]: {\n    validators: [FUNC_WITH_X_ARGUMENTS(1)]\n  },\n  [AdapterFixParams.scrollToItemOpt]: {\n    validators: [OR([BOOLEAN, OBJECT])]\n  },\n};\n\nexport const AdapterMethods: AdapterProcessMap<{ [key: string]: string }> = {\n  [Process.reset]: AdapterResetParams,\n  [Process.reload]: AdapterReloadParams,\n  [Process.prepend]: AdapterPrependParams,\n  [Process.append]: AdapterAppendParams,\n  [Process.check]: AdapterNoParams,\n  [Process.remove]: AdapterRemoveParams,\n  [Process.clip]: AdapterClipParams,\n  [Process.insert]: AdapterInsertParams,\n  [Process.replace]: AdapterReplaceParams,\n  [Process.update]: AdapterUpdateParams,\n  [Process.fix]: AdapterFixParams,\n};\n\nexport const ADAPTER_METHODS: AdapterProcessMap<ICommonProps<PropertyKey>> = {\n  [Process.reset]: RESET_METHOD_PARAMS,\n  [Process.reload]: RELOAD_METHOD_PARAMS,\n  [Process.prepend]: PREPEND_METHOD_PARAMS,\n  [Process.append]: APPEND_METHOD_PARAMS,\n  [Process.check]: NO_METHOD_PARAMS,\n  [Process.remove]: REMOVE_METHOD_PARAMS,\n  [Process.clip]: CLIP_METHOD_PARAMS,\n  [Process.insert]: INSERT_METHOD_PARAMS,\n  [Process.replace]: REPLACE_METHOD_PARAMS,\n  [Process.update]: UPDATE_METHOD_PARAMS,\n  [Process.fix]: FIX_METHOD_PARAMS,\n};\n","import { SETTINGS, DEV_SETTINGS, validate, validateOne, VALIDATORS, SizeStrategy, Direction } from '../inputs/index';\nimport { Settings as ISettings, DevSettings as IDevSettings, ICommonProps, ItemsProcessor } from '../interfaces/index';\n\nexport class Settings<Data = unknown> implements ISettings, IDevSettings {\n\n  // user settings\n  adapter: boolean;\n  startIndex: number;\n  minIndex: number;\n  maxIndex: number;\n  itemSize: number;\n  bufferSize: number;\n  padding: number;\n  infinite: boolean;\n  horizontal: boolean;\n  windowViewport: boolean;\n  viewportElement: HTMLElement | (() => void) | null;\n  inverse: boolean; // if true, bwd padding element will have a priority when filling the viewport (if lack of items)\n  onBeforeClip: ItemsProcessor | null; // if set, it will be run before clipping items from Buffer after they are hidden\n  sizeStrategy: SizeStrategy; // \"average\" | \"frequent\", determines behavior of unknown items\n\n  /**\n   * Development setting.\n   * If true, logging is enabled.\n   * Default value: false.\n   * @type {boolean}\n   */\n  debug: boolean; // if true, \n\n  /**\n   * Development setting.\n   * If false, in-memory logging is enabled, Adapter.showLog() method should be called to print the log.\n   * Default value: true.\n   * @type {boolean}\n   */\n  immediateLog: boolean;\n\n  /**\n   * Development setting.\n   * If true, time differences will be logged.\n   * Default value: false.\n   * @type {boolean}\n   */\n  logTime: boolean;\n\n  /**\n   * Development setting.\n   * If true, process fire/run info will be logged.\n   * Default value: false.\n   * @type {boolean}\n   */\n  logProcessRun: boolean;\n\n  /**\n   * Development setting.\n   * If set, scroll event handling is throttled (ms).\n   * Default value: 40. Minimal value: 0.\n   * @type {number} ms\n   */\n  throttle: number;\n\n  /**\n   * Development setting.\n   * If set, the Workflow initialization will be postponed (ms).\n   * Default value: 1. Minimal value: 0.\n   * @type {number} ms\n   */\n  initDelay: number;\n\n  /**\n   * Development setting.\n   * If set and the entire window is scrollable, the Workflow initialization will be postponed (ms).\n   * Default value: 40. Minimal value: 0.\n   * @type {number} ms\n   */\n  initWindowDelay: number;\n\n  /**\n   * Development setting.\n   * If true, item's data will be cached along with item's size and index.\n   * Default value: false.\n   * @type {boolean}\n   */\n  cacheData: boolean;\n\n  /**\n   * Development setting.\n   * If true, cache will not be flushed on reload.\n   * Default value: false.\n   * @type {boolean}\n   */\n  cacheOnReload: boolean;\n\n  /**\n   * Development setting.\n   * If true, the viewport will receive \"overflowAnchor: none\" css property.\n   * Default value: false.\n   * @type {boolean}\n   */\n  dismissOverflowAnchor: boolean;\n\n  /**\n   * Development setting.\n   * Determines the strategy of fixing the difference between estimated and real (rendered) sizes\n   * on scroll position adjustments. If set to 'backward', the difference is always resolved in favour of the\n   * backward direction: top/left content is fixed and appears in accordance with pre-render expectations.\n   * If set to 'forward', both directions could be used, and there is a case when bottom/right content is fixed:\n   * new items are to the left of the previously rendered\n   * and at least one previously rendered item remains.\n   * Default value: 'backward'. Allowed values: 'backward', 'forward'.\n   * @type {string}\n   */\n  directionPriority: Direction;\n\n  /**\n   * Internal setting. Stores the index of the Scroller instance.\n   * @type {number}\n   */\n  instanceIndex: number;\n\n  /**\n   * Internal setting. Stores the Workflow initialization delay based on initDelay and initWindowDelay settings.\n   * @type {number}\n   */\n  initializeDelay: number;\n\n  /**\n   * Internal setting. Stores the viewport based on viewportElement setting (which can be element or function).\n   * @type {HTMLElement|null}\n   */\n  viewport: HTMLElement | null;\n\n  constructor(\n    settings: ISettings<Data> | undefined, devSettings: IDevSettings | undefined, instanceIndex: number\n  ) {\n    this.parseInput(settings, SETTINGS);\n    this.parseInput(devSettings, DEV_SETTINGS);\n    this.instanceIndex = instanceIndex;\n    this.initializeDelay = this.getInitializeDelay();\n    this.viewport = this.getViewport();\n    // todo: min/max indexes must be ignored if infinite mode is enabled ??\n  }\n\n  parseInput(input: ISettings<Data> | IDevSettings | undefined, props: ICommonProps<PropertyKey>): void {\n    const result = validate(input, props);\n    if (!result.isValid) {\n      throw new Error('Invalid settings');\n    }\n    Object.entries(result.params).forEach(([key, par]) =>\n      Object.assign(this, { [key]: par.value })\n    );\n  }\n\n  getInitializeDelay(): number {\n    let result = 0;\n    if (this.windowViewport && this.initWindowDelay && !('scrollRestoration' in history)) {\n      result = this.initWindowDelay;\n    }\n    if (this.initDelay > 0) {\n      result = Math.max(result, this.initDelay);\n    }\n    return result;\n  }\n\n  getViewport(): HTMLElement | null {\n    if (typeof this.viewportElement !== 'function') {\n      return this.viewportElement;\n    }\n    const value = this.viewportElement();\n    const result = validateOne({ value }, 'value', { validators: [VALIDATORS.ELEMENT] });\n    if (!result.isValid) {\n      return null; // fallback to default (null) if Function didn't return HTML element synchronously\n    }\n    return result.value as HTMLElement;\n  }\n}\n","import { AdapterProcess, ProcessStatus } from './enums';\nimport { Scroller } from '../../scroller';\nimport { ADAPTER_METHODS, validate } from '../../inputs/index';\nimport { ProcessName, IBaseProcess, IBaseAdapterProcess, IAdapterInput } from '../../interfaces/index';\n\nexport const BaseProcessFactory = (process: ProcessName): IBaseProcess =>\n\n  class BaseProcess {\n\n    static process: ProcessName = process;\n\n  };\n\nexport const BaseAdapterProcessFactory = (process: AdapterProcess): IBaseAdapterProcess =>\n\n  class BaseAdapterProcess extends (BaseProcessFactory(process) as IBaseProcess) {\n\n    static process: AdapterProcess = process;\n\n    static parseInput<T>(\n      scroller: Scroller, options: T, ignoreErrors = false, _process?: AdapterProcess\n    ): IAdapterInput<T> {\n      const result: IAdapterInput<T> = {\n        data: validate(options, ADAPTER_METHODS[_process || process])\n      };\n\n      if (result.data.isValid) {\n        result.params = Object.entries(result.data.params)\n          .reduce((acc, [key, { value }]) => ({\n            ...acc,\n            [key]: value\n          }), {} as T);\n      } else {\n        scroller.logger.log(() => result.data.showErrors());\n        if (!ignoreErrors) {\n          scroller.workflow.call({\n            process,\n            status: ProcessStatus.error,\n            payload: { error: `Wrong argument of the \"${process}\" method call` }\n          });\n        }\n      }\n\n      return result;\n    }\n\n  };\n","import { BaseProcessFactory, CommonProcess, AdapterProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\nimport { ProcessName } from '../interfaces/index';\n\nconst initProcesses = [CommonProcess.init, AdapterProcess.reset, AdapterProcess.reload];\n\nexport default class Init extends BaseProcessFactory(CommonProcess.init) {\n\n  static run(scroller: Scroller, process: ProcessName): void {\n    const { state, workflow } = scroller;\n    const isInitial = initProcesses.includes(process);\n    scroller.logger.logCycle(true);\n    state.startWorkflowCycle(isInitial, process);\n    workflow.call({\n      process: Init.process,\n      status: ProcessStatus.next\n    });\n  }\n\n}\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\nimport { Direction } from '../inputs/index';\nimport { ScrollEventData, ScrollerWorkflow } from '../interfaces/index';\n\nexport default class Scroll extends BaseProcessFactory(CommonProcess.scroll) {\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  static run(scroller: Scroller, payload?: { event?: Event }): void {\n    const { workflow, viewport } = scroller;\n    const position = viewport.scrollPosition;\n\n    if (Scroll.onSynthetic(scroller, position)) {\n      return;\n    }\n\n    Scroll.onThrottle(scroller, position, () =>\n      Scroll.onScroll(scroller, workflow)\n    );\n  }\n\n  static onSynthetic(scroller: Scroller, position: number): boolean {\n    const { scroll } = scroller.state;\n    const synthPos = scroll.syntheticPosition;\n    if (synthPos !== null) {\n      if (scroll.syntheticFulfill) {\n        scroll.syntheticPosition = null;\n      }\n      if (!scroll.syntheticFulfill || synthPos === position) {\n        scroller.logger.log(() => [\n          'skipping scroll', position, `[${scroll.syntheticFulfill ? '' : 'pre-'}synthetic]`\n        ]);\n        return true;\n      }\n      scroller.logger.log(() => [\n        'synthetic scroll has been fulfilled:', position, position < synthPos ? '<' : '>', synthPos\n      ]);\n    }\n    return false;\n  }\n\n  static onThrottle(scroller: Scroller, position: number, done: () => void): void {\n    const { state: { scroll }, settings: { throttle }, logger } = scroller;\n    scroll.current = Scroll.getScrollEvent(position, scroll.previous);\n    const { direction, time } = scroll.current;\n    const timeDiff = scroll.previous ? time - scroll.previous.time : Infinity;\n    const delta = throttle - timeDiff;\n    const shouldDelay = isFinite(delta) && delta > 0;\n    const alreadyDelayed = !!scroll.scrollTimer;\n    logger.log(() => [\n      direction === Direction.backward ? '\\u2934' : '\\u2935',\n      position,\n      shouldDelay ? (timeDiff + 'ms') : '0ms',\n      shouldDelay ? (alreadyDelayed ? 'delayed' : `/ ${delta}ms delay`) : ''\n    ]);\n    if (!shouldDelay) {\n      if (scroll.scrollTimer) {\n        clearTimeout(scroll.scrollTimer);\n        scroll.scrollTimer = null;\n      }\n      done();\n      return;\n    }\n    if (!alreadyDelayed) {\n      scroll.scrollTimer = setTimeout(() => {\n        logger.log(() => {\n          const curr = Scroll.getScrollEvent(scroller.viewport.scrollPosition, scroll.current);\n          return [\n            curr.direction === Direction.backward ? '\\u2934' : '\\u2935',\n            curr.position,\n            (curr.time - time) + 'ms',\n            'triggered by timer set on',\n            position\n          ];\n        });\n        scroll.scrollTimer = null;\n        done();\n      }, delta);\n    }\n  }\n\n  static getScrollEvent(position: number, previous: ScrollEventData | null): ScrollEventData {\n    const time = Number(new Date());\n    let direction: Direction | null = Direction.forward;\n    if (previous) {\n      if (position === previous.position) {\n        direction = previous.direction;\n      } else if (position < previous.position) {\n        direction = Direction.backward;\n      }\n    }\n    return { position, direction, time };\n  }\n\n  static onScroll(scroller: Scroller, workflow: ScrollerWorkflow): void {\n    const { state: { scroll, cycle } } = scroller;\n    scroll.previous = { ...(scroll.current as ScrollEventData) };\n    scroll.current = null;\n\n    if (cycle.busy.get()) {\n      scroller.logger.log(() => ['skipping scroll', (scroll.previous as ScrollEventData).position, '[pending]']);\n      return;\n    }\n\n    workflow.call({\n      process: Scroll.process,\n      status: ProcessStatus.next\n    });\n  }\n\n}\n","import { Scroller } from '../../scroller';\nimport { DatasourceProps } from '../../inputs/index';\nimport { Datasource } from '../../classes/datasource';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport { IDatasourceOptional, ProcessPayload } from '../../interfaces/index';\n\nexport default class Reset extends BaseAdapterProcessFactory(AdapterProcess.reset) {\n\n  static run(scroller: Scroller, options?: IDatasourceOptional): void {\n    const { datasource, buffer, viewport: { paddings }, state: { cycle } } = scroller;\n\n    if (options) {\n      const { data } = Reset.parseInput(scroller, options);\n      if (!data.isValid) {\n        return;\n      }\n      const constructed = options instanceof Datasource;\n      Object.keys(DatasourceProps).forEach(key => {\n        const param = data.params[key];\n        const ds = datasource as unknown as { [key: string]: unknown };\n        if (param.isSet || (constructed && ds[key])) {\n          ds[key] = param.value;\n        }\n      });\n    }\n\n    buffer.reset(true);\n    paddings.backward.reset();\n    paddings.forward.reset();\n\n    const payload: ProcessPayload = { datasource };\n    if (cycle.busy.get()) {\n      payload.finalize = true;\n      cycle.interrupter = Reset.process;\n    }\n\n    scroller.workflow.call({\n      process: Reset.process,\n      status: ProcessStatus.next,\n      payload\n    });\n  }\n\n}\n","import { Scroller } from '../../scroller';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport { ProcessPayload } from '../../interfaces/index';\n\nexport default class Reload extends BaseAdapterProcessFactory(AdapterProcess.reload) {\n\n  static run(scroller: Scroller, reloadIndex: number): void {\n    const { viewport, state, buffer } = scroller;\n\n    const { params } = Reload.parseInput(scroller, { reloadIndex }, true);\n\n    buffer.reset(false, params ? params.reloadIndex : void 0);\n    viewport.reset(buffer.startIndex);\n\n    const payload: ProcessPayload = {};\n    if (state.cycle.busy.get()) {\n      state.scroll.stop();\n      payload.finalize = true;\n      state.cycle.interrupter = Reload.process;\n    }\n\n    scroller.workflow.call({\n      process: Reload.process,\n      status: ProcessStatus.next,\n      payload\n    });\n  }\n\n}\n","import { Routines } from './domRoutines';\nimport { Direction } from '../inputs/index';\nimport { Item as _Item, ItemAdapter } from '../interfaces/index';\n\nexport class Item<Data = unknown> implements _Item<Data> {\n  nodeId: string;\n  routines: Routines;\n  preSize: number; // estimated size\n  size: number; // real size\n  invisible: boolean;\n  toRemove: boolean;\n  toInsert: boolean;\n  removeDirection: Direction;\n\n  private container: ItemAdapter<Data>;\n\n  get $index(): number {\n    return this.container.$index;\n  }\n  set $index(value: number) {\n    this.container.$index = value;\n  }\n\n  get data(): Data {\n    return this.container.data;\n  }\n  set data(value: Data) {\n    this.container.data = value;\n  }\n\n  get element(): HTMLElement {\n    return this.container.element as HTMLElement;\n  }\n  set element(value: HTMLElement) {\n    this.container.element = value;\n  }\n\n  constructor($index: number, data: Data, routines: Routines) {\n    this.container = {\n      $index,\n      data\n    };\n    this.nodeId = String($index);\n    this.routines = routines;\n    this.invisible = true;\n    this.toRemove = false;\n    this.toInsert = false;\n  }\n\n  dispose(): void {\n    delete this.container.element;\n  }\n\n  setSize(preSize = 0): void {\n    this.preSize = preSize;\n    if (this.element) {\n      this.size = this.routines.getSize(this.element);\n    }\n  }\n\n  makeVisible(): void {\n    this.routines.makeElementVisible(this.element);\n    this.invisible = false;\n  }\n\n  hide(): void {\n    if (this.element) {\n      this.routines.hideElement(this.element);\n    }\n  }\n\n  scrollTo(argument?: boolean | ScrollIntoViewOptions): void {\n    if (this.element) {\n      this.routines.scrollTo(this.element, argument);\n    }\n  }\n\n  updateIndex(index: number): void {\n    this.$index = index;\n    this.nodeId = String(index);\n  }\n\n  get(): ItemAdapter<Data> {\n    return this.container;\n  }\n}\n","import { Scroller } from '../../scroller';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport { Item } from '../../classes/item';\nimport { Direction } from '../../inputs/index';\nimport { AdapterUpdateOptions } from '../../interfaces/index';\n\nexport default class Update extends BaseAdapterProcessFactory(AdapterProcess.update) {\n\n  static run(scroller: Scroller, options: AdapterUpdateOptions): void {\n    const { params } = Update.parseInput(scroller, options);\n    if (!params) {\n      return;\n    }\n\n    const shouldUpdate = Update.doUpdate(scroller, params);\n\n    scroller.workflow.call({\n      process: Update.process,\n      status: shouldUpdate ? ProcessStatus.next : ProcessStatus.done\n    });\n  }\n\n  static doUpdate(scroller: Scroller, params: AdapterUpdateOptions): boolean {\n    const { buffer, viewport, state: { fetch }, routines, logger } = scroller;\n    if (!buffer.items) {\n      logger.log(() => 'no items in Buffer');\n      return false;\n    }\n    const { item: firstItem, index: firstIndex, diff: firstItemDiff } =\n      viewport.getEdgeVisibleItem(buffer.items, Direction.backward);\n\n    const { trackedIndex, toRemove } = buffer.updateItems(\n      params.predicate,\n      (index, data) => new Item(index, data, routines),\n      firstIndex,\n      !!params.fixRight\n    );\n\n    let delta = 0;\n    const trackedItem = buffer.get(trackedIndex);\n    if (firstItem && firstItem === trackedItem) {\n      delta = - buffer.getSizeByIndex(trackedIndex) + firstItemDiff;\n    }\n\n    toRemove.forEach(item => item.hide());\n    logger.log(() => toRemove.length\n      ? 'items to remove: [' + toRemove.map(({ $index }) => $index).join(',') + ']'\n      : 'no items to remove'\n    );\n    if (toRemove.length) { // insertions will be processed on render\n      buffer.checkDefaultSize();\n    }\n\n    const toRender = buffer.items.filter(({ toInsert }) => toInsert);\n    logger.log(() => toRender.length\n      ? 'items to render: [' + toRender.map(({ $index }) => $index).join(',') + ']'\n      : 'no items to render'\n    );\n\n    fetch.update(trackedIndex, delta, toRender, toRemove);\n    return !!toRemove.length || !!toRender.length;\n  }\n\n}\n","import { Scroller } from '../../scroller';\nimport Update from './update';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport { Item } from '../../classes/item';\nimport { Direction } from '../../inputs/index';\nimport { AdapterInsertOptions, AdapterUpdateOptions } from '../../interfaces/index';\n\nexport default class Insert extends BaseAdapterProcessFactory(AdapterProcess.insert) {\n\n  static run(scroller: Scroller, options: AdapterInsertOptions): void {\n    const { params } = Insert.parseInput(scroller, options);\n    if (!params) {\n      return;\n    }\n    const shouldInsert = Insert.doInsert(scroller, params);\n\n    scroller.workflow.call({\n      process: Insert.process,\n      status: shouldInsert ? ProcessStatus.next : ProcessStatus.done\n    });\n  }\n\n  static doInsert(scroller: Scroller, params: AdapterInsertOptions): boolean {\n    if (!Insert.insertEmpty(scroller, params)) {\n      if (!Insert.insertInBuffer(scroller, params)) {\n        if (!Insert.insertVirtually(scroller, params)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  static insertEmpty(scroller: Scroller, params: AdapterInsertOptions): boolean {\n    const { buffer, routines, state: { fetch } } = scroller;\n    if (buffer.size) {\n      return false;\n    }\n    const { beforeIndex, afterIndex, items, decrease } = params;\n    if (!buffer.fillEmpty(\n      items, beforeIndex, afterIndex, !!decrease,\n      (index, data) => new Item(index, data, routines)\n    )) {\n      return false;\n    }\n    fetch.fill(buffer.items, buffer.startIndex);\n\n    return true;\n  }\n\n  static insertInBuffer(scroller: Scroller, params: AdapterInsertOptions): boolean {\n    const { before, after, beforeIndex, afterIndex, items, decrease } = params;\n    const indexToInsert = scroller.buffer.getIndexToInsert(before || after, beforeIndex, afterIndex);\n\n    if (isNaN(indexToInsert)) {\n      return false;\n    }\n    const isBackward = Number.isInteger(beforeIndex) || before;\n\n    const updateOptions: AdapterUpdateOptions = {\n      predicate: ({ $index, data }) => {\n        if (indexToInsert === $index) {\n          return isBackward ? [...items, data] : [data, ...items];\n        }\n        return true;\n      },\n      fixRight: decrease\n    };\n\n    return Update.doUpdate(scroller, updateOptions);\n  }\n\n  static insertVirtually(scroller: Scroller, params: AdapterInsertOptions): boolean {\n    const { beforeIndex, afterIndex, items, decrease } = params;\n    const { buffer, state: { fetch }, viewport } = scroller;\n    const direction = Number.isInteger(beforeIndex) ? Direction.backward : Direction.forward;\n    const indexToInsert = (direction === Direction.backward ? beforeIndex : afterIndex) as number;\n\n    if (!buffer.insertVirtually(items, indexToInsert, direction, !!decrease)) {\n      return false;\n    }\n\n    const { index, diff } = viewport.getEdgeVisibleItem(buffer.items, Direction.backward);\n    fetch.firstVisible.index = index;\n    if (!isNaN(index)) {\n      fetch.simulate = true;\n      fetch.firstVisible.delta = - buffer.getSizeByIndex(index) + diff;\n    }\n\n    return true;\n  }\n\n}\n","import { Scroller } from '../../scroller';\nimport Insert from './insert';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport { AdapterAppendOptions, AdapterPrependOptions } from '../../interfaces/index';\n\ntype AdapterAppendPrependOptions = AdapterAppendOptions & AdapterPrependOptions;\n\ninterface AppendRunOptions {\n  process: AdapterProcess;\n  options: AdapterAppendPrependOptions;\n}\n\nexport default class Append extends BaseAdapterProcessFactory(AdapterProcess.append) {\n\n  static run(scroller: Scroller, { process, options }: AppendRunOptions): void {\n    const { params } = Append.parseInput(scroller, options, false, process);\n    if (!params) {\n      return;\n    }\n\n    const shouldAppend = Append.doAppend(scroller, process, params);\n\n    scroller.workflow.call({\n      process: Append.process,\n      status: shouldAppend ? ProcessStatus.next : ProcessStatus.done\n    });\n  }\n\n  static doAppend(scroller: Scroller, process: AdapterProcess, params: AdapterAppendPrependOptions): boolean {\n    const { bof, eof, increase, decrease } = params;\n    const { buffer } = scroller;\n    const prepend = process === AdapterProcess.prepend;\n    const opposite = prepend ? !increase : decrease;\n    let beforeIndex, afterIndex, items = params.items;\n    if (prepend) {\n      beforeIndex = (bof ? buffer.absMinIndex : buffer.minIndex) + (!buffer.size ? 1 : 0);\n      items = [...items].reverse();\n    } else {\n      afterIndex = (eof ? buffer.absMaxIndex : buffer.maxIndex) - (!buffer.size && !opposite ? 1 : 0);\n    }\n    return Insert.doInsert(scroller, {\n      items,\n      beforeIndex,\n      afterIndex,\n      decrease: opposite\n    });\n  }\n\n}\n","import { Scroller } from '../../scroller';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport { Direction } from '../../inputs/index';\n\nexport default class Check extends BaseAdapterProcessFactory(AdapterProcess.check) {\n\n  static run(scroller: Scroller): void {\n    const { workflow, buffer, state: { fetch }, viewport } = scroller;\n    let min = Infinity, max = -Infinity;\n\n    buffer.items.forEach(item => {\n      const size = item.size;\n      item.setSize();\n      if (item.size !== size) {\n        buffer.cacheItem(item);\n        min = Math.min(min, item.$index);\n        max = Math.max(max, item.$index);\n      }\n    });\n\n    if (Number.isFinite(min)) {\n      fetch.first.indexBuffer = buffer.firstIndex;\n      fetch.last.indexBuffer = buffer.lastIndex;\n      const { index: firstIndex, diff } = viewport.getEdgeVisibleItem(buffer.items, Direction.backward);\n      fetch.firstVisible.index = firstIndex;\n      if (!isNaN(firstIndex)) {\n        fetch.firstVisible.delta = - buffer.getSizeByIndex(firstIndex) + diff;\n      }\n      fetch.check(\n        buffer.items.filter(item => item.$index >= min && item.$index <= max)\n      );\n    }\n\n    scroller.logger.stat('check');\n\n    workflow.call({\n      process: Check.process,\n      status: Number.isFinite(min) ? ProcessStatus.next : ProcessStatus.done\n    });\n  }\n\n}\n","import { Scroller } from '../../scroller';\nimport Update from './update';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport { Direction } from '../../inputs/index';\nimport { AdapterRemoveOptions, AdapterUpdateOptions, ItemsPredicate } from '../../interfaces/index';\n\nexport default class Remove extends BaseAdapterProcessFactory(AdapterProcess.remove) {\n\n  static run(scroller: Scroller, options: AdapterRemoveOptions): void {\n    const { params } = Remove.parseInput(scroller, options);\n    if (!params) {\n      return;\n    }\n    const shouldRemove = Remove.doRemove(scroller, params);\n\n    scroller.workflow.call({\n      process: Remove.process,\n      status: shouldRemove ? ProcessStatus.next : ProcessStatus.done\n    });\n  }\n\n  static doRemove(scroller: Scroller, params: AdapterRemoveOptions): boolean {\n    const { fetch } = scroller.state;\n    fetch.firstVisible.index = NaN;\n    const removed = Remove.removeBufferedItems(scroller, params);\n    const shouldBuffered = removed.length > 0;\n    if (shouldBuffered) {\n      // exclude just removed in-buffer indexes\n      if (params.indexes && params.indexes.length) {\n        params.indexes = params.indexes.filter(i => !removed.includes(i));\n      }\n      // shift virtual indexes that remain\n      if (params.indexes && params.indexes.length) {\n        const diffLeft = (params.increase ? 1 : 0) * removed.length;\n        const diffRight = (params.increase ? 0 : -1) * removed.length;\n        params.indexes = params.indexes.map(index =>\n          index + (index < removed[0] ? diffLeft : diffRight)\n        );\n      }\n    }\n    const shouldVirtual = Remove.removeVirtualItems(scroller, params);\n    if (!shouldBuffered && !shouldVirtual) {\n      return false;\n    }\n    scroller.logger.stat('after remove');\n    return true;\n  }\n\n  static removeBufferedItems(scroller: Scroller, options: AdapterRemoveOptions): number[] {\n    const { predicate, indexes, increase } = options;\n    if (!predicate && !indexes) {\n      return [];\n    }\n    const newPredicate: ItemsPredicate = item =>\n      (predicate && predicate(item)) ||\n      (!!indexes && indexes.includes(item.$index));\n\n    const indexesToRemove: number[] = scroller.buffer.items.reduce((acc, item) =>\n      newPredicate(item) ? [...acc, item.$index] : acc, [] as number[]\n    );\n    const updateOptions: AdapterUpdateOptions = {\n      predicate: item => !newPredicate(item),\n      fixRight: increase\n    };\n    Update.doUpdate(scroller, updateOptions);\n    return indexesToRemove;\n  }\n\n  static removeVirtualItems(scroller: Scroller, params: AdapterRemoveOptions): boolean {\n    const { indexes, increase } = params;\n    if (!indexes || !indexes.length) {\n      return false;\n    }\n    const { buffer, viewport, state: { fetch } } = scroller;\n\n    // get items to remove\n    const { finiteAbsMinIndex, firstIndex, finiteAbsMaxIndex, lastIndex } = buffer;\n    const toRemove = [];\n    for (let i = 0, len = indexes.length; i < len; i++) {\n      const index = indexes[i];\n      if (index >= finiteAbsMinIndex && !isNaN(firstIndex) && index < firstIndex) {\n        toRemove.push(index); // backward;\n      } else if (index <= finiteAbsMaxIndex && !isNaN(lastIndex) && index > lastIndex) {\n        toRemove.push(index); // forward;\n      } else {\n        continue;\n      }\n    }\n\n    if (!toRemove.length) {\n      return false;\n    }\n\n    // what should be shown after remove; Buffer removal has priority\n    if (isNaN(fetch.firstVisible.index)) {\n      const { index, diff } = viewport.getEdgeVisibleItem(buffer.items, Direction.backward);\n      fetch.firstVisible.index = index;\n      if (!isNaN(index)) {\n        fetch.firstVisible.delta = - buffer.getSizeByIndex(index) + diff;\n      }\n    }\n\n    // virtual removal\n    scroller.logger.log(() => `going to remove ${toRemove.length} item(s) virtually`);\n    buffer.removeVirtually(toRemove, !!increase);\n    buffer.checkDefaultSize();\n    Remove.shiftFirstVisibleIndex(scroller, toRemove, !!increase);\n\n    return true;\n  }\n\n  static shiftFirstVisibleIndex(scroller: Scroller, listToRemove: number[], increase: boolean): void {\n    const { firstVisible } = scroller.state.fetch;\n    if (isNaN(firstVisible.index)) {\n      return;\n    }\n    const shift = listToRemove.reduce((acc, index) => acc + (\n      ((increase && index > firstVisible.index) || (!increase && index < firstVisible.index)) ? 1 : 0\n    ), 0);\n    firstVisible.index = firstVisible.index + (increase ? shift : -shift);\n  }\n\n}\n","import { Scroller } from '../../scroller';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport { AdapterClipOptions } from '../../interfaces/index';\n\nexport default class UserClip extends BaseAdapterProcessFactory(AdapterProcess.clip) {\n\n  static run(scroller: Scroller, options?: AdapterClipOptions): void {\n    const { params } = UserClip.parseInput(scroller, options);\n\n    scroller.state.clip.forceForward = !(params && params.backwardOnly);\n    scroller.state.clip.forceBackward = !(params && params.forwardOnly);\n\n    scroller.workflow.call({\n      process: UserClip.process,\n      status: ProcessStatus.next\n    });\n  }\n\n}\n","import { Scroller } from '../../scroller';\nimport Update from './update';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport { AdapterReplaceOptions, AdapterUpdateOptions } from '../../interfaces/index';\n\nexport default class Replace extends BaseAdapterProcessFactory(AdapterProcess.replace) {\n\n  static run(scroller: Scroller, options: AdapterReplaceOptions): void {\n    const { params } = Replace.parseInput(scroller, options);\n    if (!params) {\n      return;\n    }\n    const shouldReplace = Replace.doReplace(scroller, params);\n\n    scroller.workflow.call({\n      process: Replace.process,\n      status: shouldReplace ? ProcessStatus.next : ProcessStatus.done,\n    });\n  }\n\n  static doReplace(scroller: Scroller, params: AdapterReplaceOptions): boolean {\n    const toRemove = scroller.buffer.items\n      .filter(item => params.predicate(item))\n      .map(item => item.$index);\n\n    if (!toRemove.length) {\n      scroller.logger.log('no items to be replaced');\n      return false;\n    }\n\n    let injected = false;\n    const updateOptions: AdapterUpdateOptions = {\n      predicate: ({ $index }) => {\n        if (!toRemove.includes($index)) {\n          return true;\n        }\n        if (!injected) {\n          injected = true;\n          return params.items;\n        }\n        return false;\n      },\n      fixRight: params.fixRight\n    };\n\n    return Update.doUpdate(scroller, updateOptions);\n  }\n\n}\n","import { Scroller } from '../../scroller';\nimport { AdapterMethods } from '../../inputs/index';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport {\n  ItemsPredicate,\n  ItemsUpdater,\n  AdapterFixOptions,\n  IValidatedData,\n} from '../../interfaces/index';\n\nconst { [AdapterProcess.fix]: FixParams } = AdapterMethods;\n\nexport default class Fix extends BaseAdapterProcessFactory(AdapterProcess.fix) {\n\n  static run(scroller: Scroller, options: AdapterFixOptions): void {\n    const { workflow } = scroller;\n\n    const { data, params } = Fix.parseInput(scroller, options);\n    if (!params) {\n      return;\n    }\n\n    Object.entries(data.params).forEach(([key, value]) => {\n      if (value.isSet && value.isValid) {\n        Fix.runByType(scroller, key, value.value, data);\n      }\n    });\n\n    workflow.call({\n      process: Fix.process,\n      status: ProcessStatus.done\n    });\n  }\n\n  static runByType(scroller: Scroller, token: string, value: unknown, methodData: IValidatedData): void {\n    switch (token) {\n      case FixParams.scrollPosition:\n        return Fix.setScrollPosition(scroller, value as number);\n      case FixParams.minIndex:\n        return Fix.setMinIndex(scroller, value as number);\n      case FixParams.maxIndex:\n        return Fix.setMaxIndex(scroller, value as number);\n      case FixParams.updater:\n        return Fix.updateItems(scroller, value as ItemsUpdater);\n      case FixParams.scrollToItem:\n        if (methodData.params) {\n          const scrollToItemOpt = methodData.params[FixParams.scrollToItemOpt];\n          const options = scrollToItemOpt ? scrollToItemOpt.value as AdapterFixOptions['scrollToItemOpt'] : void 0;\n          return Fix.scrollToItem(scroller, value as ItemsPredicate, options);\n        }\n        return;\n      case FixParams.scrollToItemOpt:\n        return;\n    }\n  }\n\n  static setScrollPosition({ viewport }: Scroller, value: number): void {\n    let result = value;\n    if (value === -Infinity) {\n      result = 0;\n    } else if (value === Infinity) {\n      result = viewport.getScrollableSize();\n    }\n    viewport.setPosition(result);\n  }\n\n  static setMinIndex({ buffer, settings }: Scroller, value: number): void {\n    settings.minIndex = value;\n    buffer.absMinIndex = value;\n  }\n\n  static setMaxIndex({ buffer, settings }: Scroller, value: number): void {\n    settings.maxIndex = value;\n    buffer.absMaxIndex = value;\n  }\n\n  static updateItems({ buffer, logger }: Scroller, value: ItemsUpdater): void {\n    let updateReference = false;\n    const updater = () => updateReference = true;\n    buffer.items.forEach(item => value(item.get(), updater));\n    if (updateReference) {\n      logger.log(() => 'update Buffer.items reference');\n      buffer.items = [...buffer.items];\n    }\n  }\n\n  static scrollToItem(scroller: Scroller, value: ItemsPredicate, options?: boolean | ScrollIntoViewOptions): void {\n    const found = scroller.buffer.items.find(item => value(item.get()));\n    if (!found) {\n      scroller.logger.log(() => 'scrollToItem cancelled, item not found');\n      return;\n    }\n    found.scrollTo(options);\n  }\n\n}\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\n\nexport default class Start extends BaseProcessFactory(CommonProcess.start) {\n\n  static run(scroller: Scroller): void {\n    const payload = scroller.state.startInnerLoop();\n\n    scroller.workflow.call({\n      process: Start.process,\n      status: ProcessStatus.next,\n      payload\n    });\n  }\n\n}\n","import { BaseProcessFactory, CommonProcess, AdapterProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\nimport { Direction } from '../inputs/index';\n\nexport default class PreFetch extends BaseProcessFactory(CommonProcess.preFetch) {\n\n  static run(scroller: Scroller): void {\n    const { workflow, buffer, state: { fetch, cycle } } = scroller;\n    fetch.minIndex = buffer.minIndex;\n\n    // set first and last indexes of items to fetch\n    PreFetch.setPositionsAndIndexes(scroller);\n\n    // skip indexes that are in buffer\n    PreFetch.skipBufferedItems(scroller);\n\n    if (scroller.settings.infinite) {\n      // fill indexes to include buffer if no clip\n      PreFetch.checkBufferGaps(scroller);\n    }\n\n    // add indexes if there are too few items to fetch (clip padding)\n    PreFetch.checkFetchPackSize(scroller);\n\n    // set fetch direction\n    PreFetch.setFetchDirection(scroller);\n\n    workflow.call({\n      process: PreFetch.process,\n      status: PreFetch.getStatus(scroller),\n      payload: { process: cycle.initiator }\n    });\n  }\n\n  static setPositionsAndIndexes(scroller: Scroller): void {\n    PreFetch.setPositions(scroller);\n    PreFetch.setFirstIndex(scroller);\n    PreFetch.setLastIndex(scroller);\n    scroller.logger.fetch();\n  }\n\n  static setPositions(scroller: Scroller): void {\n    const { state: { fetch: { positions } }, viewport } = scroller;\n    const paddingDelta = viewport.getBufferPadding();\n    positions.before = viewport.scrollPosition;\n    positions.startDelta = PreFetch.getStartDelta(scroller);\n    positions.relative = positions.before - positions.startDelta;\n    positions.start = positions.relative - paddingDelta;\n    positions.end = positions.relative + viewport.getSize() + paddingDelta;\n  }\n\n  static getStartDelta(scroller: Scroller): number { // calculate size before start index\n    const { buffer, viewport: { offset } } = scroller;\n    let startDelta = 0;\n    if (offset) {\n      startDelta += offset;\n    }\n    if (!buffer.defaultSize) {\n      return startDelta;\n    }\n    for (let index = buffer.finiteAbsMinIndex; index < buffer.startIndex; index++) {\n      startDelta += buffer.getSizeByIndex(index);\n    }\n    scroller.logger.log(() => [\n      `start delta is ${startDelta}`, ...(offset ? [` (+${offset} offset)`] : [])\n    ]);\n    return startDelta;\n  }\n\n  static setFirstIndex(scroller: Scroller): void {\n    const { state, buffer } = scroller;\n    const { positions: { start }, first } = state.fetch;\n    let firstIndex = buffer.startIndex;\n    let firstIndexPosition = 0;\n    if (state.cycle.innerLoop.isInitial) {\n      scroller.logger.log('skipping fetch backward direction [initial loop]');\n    } else if (!buffer.defaultSize) {\n      scroller.logger.log('skipping fetch backward direction [no item size]');\n    } else {\n      let position = firstIndexPosition;\n      let index = firstIndex;\n      while (1) { // eslint-disable-line no-constant-condition\n        if (start >= 0) {\n          const size = buffer.getSizeByIndex(index);\n          const diff = (position + size) - start;\n          if (diff > 0) {\n            firstIndex = index;\n            firstIndexPosition = position;\n            break;\n          }\n          position += size;\n          index++;\n          if (index < buffer.absMinIndex) {\n            break;\n          }\n        }\n        if (start < 0) {\n          index--;\n          if (index < buffer.absMinIndex) {\n            break;\n          }\n          position -= buffer.getSizeByIndex(index);\n          const diff = position - start;\n          firstIndex = index;\n          firstIndexPosition = position;\n          if (diff <= 0) {\n            break;\n          }\n        }\n      }\n    }\n    first.index = first.indexBuffer = Math.max(firstIndex, buffer.absMinIndex);\n    first.position = firstIndexPosition;\n  }\n\n  static setLastIndex(scroller: Scroller): void {\n    const { state: { fetch, cycle }, buffer, settings } = scroller;\n    const { firstVisible, positions: { relative, end }, first, last } = fetch;\n    let lastIndex;\n    if (!buffer.defaultSize) {\n      // just to fetch forward bufferSize items if neither averageItemSize nor itemSize are present\n      lastIndex = buffer.startIndex + settings.bufferSize - 1;\n      scroller.logger.log('forcing fetch forward direction [no item size]');\n    } else {\n      let index = first.indexBuffer;\n      let position = first.position;\n      lastIndex = index;\n      while (1) { // eslint-disable-line no-constant-condition\n        lastIndex = index;\n        const size = buffer.getSizeByIndex(index);\n        position += size;\n        if (isNaN(firstVisible.index) && position > relative) {\n          firstVisible.index = index;\n          if (!cycle.innerLoop.isInitial) {\n            firstVisible.delta = position - size - relative;\n          }\n        }\n        if (position >= end) {\n          break;\n        }\n        if (index++ > buffer.absMaxIndex) {\n          break;\n        }\n      }\n    }\n    last.index = last.indexBuffer = Math.min(lastIndex, buffer.absMaxIndex);\n  }\n\n  static skipBufferedItems(scroller: Scroller): void {\n    const { buffer } = scroller;\n    if (!buffer.size) {\n      return;\n    }\n    const { fetch } = scroller.state;\n    const firstIndex = fetch.first.index;\n    const lastIndex = fetch.last.index;\n    const packs: number[][] = [[]];\n    let p = 0;\n    for (let i = firstIndex; i <= lastIndex; i++) {\n      if (!buffer.get(i)) {\n        packs[p].push(i);\n      } else if (packs[p].length) {\n        packs[++p] = [];\n      }\n    }\n    let pack = packs[0];\n    if (packs[0].length && packs[1] && packs[1].length) {\n      fetch.hasAnotherPack = true;\n      // todo: need to look for biggest pack in visible area\n      // todo: or think about merging two requests in a single Fetch process\n      if (packs[1].length >= packs[0].length) {\n        pack = packs[1];\n      }\n    }\n    fetch.first.index = Math.max(pack[0], buffer.absMinIndex);\n    fetch.last.index = Math.min(pack[pack.length - 1], buffer.absMaxIndex);\n    if (fetch.first.index !== firstIndex || fetch.last.index !== lastIndex) {\n      scroller.logger.fetch('after Buffer flushing');\n    }\n  }\n\n  static checkBufferGaps(scroller: Scroller): void {\n    const { buffer, state: { fetch } } = scroller;\n    if (!buffer.size) {\n      return;\n    }\n    const fetchFirst = fetch.first.index;\n    const bufferLast = buffer.lastIndex;\n    if (fetchFirst > bufferLast) {\n      fetch.first.index = fetch.first.indexBuffer = bufferLast + 1;\n    }\n    const bufferFirst = buffer.firstIndex;\n    const fetchLast = fetch.last.index;\n    if (fetchLast < bufferFirst) {\n      fetch.last.index = fetch.last.indexBuffer = bufferFirst - 1;\n    }\n    if (fetch.first.index !== fetchFirst || fetch.last.index !== fetchLast) {\n      scroller.logger.fetch('after Buffer filling (no clip case)');\n    }\n  }\n\n  static checkFetchPackSize(scroller: Scroller): void {\n    const { buffer, state: { fetch } } = scroller;\n    if (!fetch.shouldFetch) {\n      return;\n    }\n    const firstIndex = fetch.first.index;\n    const lastIndex = fetch.last.index;\n    const diff = scroller.settings.bufferSize - (lastIndex - firstIndex + 1);\n    if (diff <= 0) {\n      return;\n    }\n    if (!buffer.size || lastIndex > buffer.items[0].$index) { // forward\n      const newLastIndex = Math.min(lastIndex + diff, buffer.absMaxIndex);\n      if (newLastIndex > lastIndex) {\n        fetch.last.index = fetch.last.indexBuffer = newLastIndex;\n      }\n    } else {\n      const newFirstIndex = Math.max(firstIndex - diff, buffer.absMinIndex);\n      if (newFirstIndex < firstIndex) {\n        fetch.first.index = fetch.first.indexBuffer = newFirstIndex;\n      }\n    }\n    if (fetch.first.index !== firstIndex || fetch.last.index !== lastIndex) {\n      scroller.logger.fetch('after bufferSize adjustment');\n      PreFetch.skipBufferedItems(scroller);\n    }\n  }\n\n  static setFetchDirection(scroller: Scroller): void {\n    const { buffer, state: { fetch } } = scroller;\n    if (fetch.last.index) {\n      let direction = Direction.forward;\n      if (buffer.size) {\n        direction = fetch.last.index < buffer.items[0].$index ? Direction.backward : Direction.forward;\n      }\n      fetch.direction = direction;\n      scroller.logger.log(() => `fetch direction is \"${direction}\"`);\n    }\n  }\n\n  static getStatus(scroller: Scroller): ProcessStatus {\n    const { cycle, fetch } = scroller.state;\n    if (cycle.initiator === AdapterProcess.clip) {\n      scroller.logger.log(() => `going to skip fetch due to \"${AdapterProcess.clip}\" process`);\n      return ProcessStatus.next;\n    }\n    if (fetch.shouldFetch) {\n      scroller.logger.log(() => `going to fetch ${fetch.count} items started from index ${fetch.index}`);\n      return ProcessStatus.next;\n    }\n    return ProcessStatus.done;\n  }\n\n}\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\nimport { ObservableLike } from '../interfaces/index';\n\ninterface Immediate {\n  data: unknown[] | null;\n  error: unknown | null;\n  isError: boolean;\n}\n\ntype FetchGetResult = Immediate | Promise<unknown>;\n\ninterface FetchBox {\n  success: (value: unknown[]) => void;\n  fail: (value: unknown) => void;\n}\n\nexport default class Fetch extends BaseProcessFactory(CommonProcess.fetch) {\n\n  static run(scroller: Scroller): void {\n    const { workflow } = scroller;\n\n    const box = {\n      success: (data: unknown[]) => {\n        scroller.logger.log(() =>\n          `resolved ${data.length} items ` +\n          `(index = ${scroller.state.fetch.index}, count = ${scroller.state.fetch.count})`\n        );\n        scroller.state.fetch.newItemsData = data;\n        workflow.call({\n          process: Fetch.process,\n          status: ProcessStatus.next\n        });\n      },\n      fail: (error: unknown) =>\n        workflow.call({\n          process: Fetch.process,\n          status: ProcessStatus.error,\n          payload: { error }\n        })\n    };\n\n    const result = Fetch.get(scroller);\n    Fetch.complete(scroller, box, result);\n  }\n\n  static complete(scroller: Scroller, box: FetchBox, result: FetchGetResult): void {\n    if (Object.prototype.hasOwnProperty.call(result, 'data')) {\n      const { data, error, isError } = result as Immediate;\n      if (!isError) {\n        box.success(data || []);\n      } else {\n        box.fail(error);\n      }\n    } else {\n      const { state: { scroll, fetch }, viewport } = scroller;\n      if (scroll.positionBeforeAsync === null) {\n        scroll.positionBeforeAsync = viewport.scrollPosition;\n      }\n      fetch.cancel = () => {\n        box.success = () => null;\n        box.fail = () => null;\n      };\n      (result as Promise<unknown[]>).then(\n        (data) => box.success(data),\n        (error) => box.fail(error)\n      );\n    }\n  }\n\n  static get(scroller: Scroller): FetchGetResult {\n    const _get = scroller.datasource.get;\n    const { index, count } = scroller.state.fetch;\n\n    let immediateData, immediateError;\n    let resolve: (value: unknown) => void, reject: (value: unknown) => void;\n\n    const done = (data: unknown[]) => {\n      if (!resolve) {\n        immediateData = data || null;\n        return;\n      }\n      resolve(data);\n    };\n    const fail = (error: unknown) => {\n      if (!reject) {\n        immediateError = error || null;\n        return;\n      }\n      reject(error);\n    };\n\n    const getResult = _get(index, count, done, fail);\n\n    if (getResult && typeof getResult === 'object' && getResult !== null) {\n      if (typeof (getResult as PromiseLike<unknown>).then === 'function') {\n        return getResult as Promise<unknown>;\n      } else if (typeof (getResult as ObservableLike).subscribe === 'function') {\n        const sub = (getResult as ObservableLike).subscribe(done, fail, () => {\n          if (sub && typeof sub === 'object' && typeof sub.unsubscribe === 'function') {\n            sub.unsubscribe();\n          }\n        });\n      }\n    }\n\n    if (immediateData || immediateError) { // callback case or immediate observable\n      return {\n        data: immediateError ? null : (immediateData || []),\n        error: immediateError,\n        isError: !!immediateError\n      };\n    }\n\n    return new Promise((_resolve, _reject) => {\n      resolve = _resolve;\n      reject = _reject;\n    });\n  }\n\n}\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\nimport { Item } from '../classes/item';\n\nexport default class PostFetch extends BaseProcessFactory(CommonProcess.postFetch) {\n\n  static run(scroller: Scroller): void {\n    const { workflow } = scroller;\n    if (PostFetch.setItems(scroller)) {\n      PostFetch.setBufferLimits(scroller);\n      workflow.call({\n        process: PostFetch.process,\n        status: scroller.state.fetch.hasNewItems\n          ? ProcessStatus.next\n          : ProcessStatus.done\n      });\n    } else {\n      workflow.call({\n        process: PostFetch.process,\n        status: ProcessStatus.error,\n        payload: { error: 'Can\\'t set buffer items' }\n      });\n    }\n  }\n\n  static setBufferLimits(scroller: Scroller): void {\n    const { buffer, state: { fetch, cycle: { innerLoop } } } = scroller;\n    const { items, first: { index: first }, last: { index: last } } = fetch;\n    if (!items.length) {\n      if (last < buffer.minIndex || innerLoop.isInitial) {\n        buffer.absMinIndex = buffer.minIndex;\n      }\n      if (first > buffer.maxIndex || innerLoop.isInitial) {\n        buffer.absMaxIndex = buffer.maxIndex;\n      }\n    } else {\n      const lastIndex = items.length - 1;\n      if (first < items[0].$index) {\n        buffer.absMinIndex = items[0].$index;\n      }\n      if (last > items[lastIndex].$index) {\n        buffer.absMaxIndex = items[lastIndex].$index;\n      }\n    }\n  }\n\n  static setItems(scroller: Scroller): boolean {\n    const { buffer, state: { fetch, cycle } } = scroller;\n    const items = fetch.newItemsData;\n    if (!items || !items.length) { // empty result\n      return true;\n    }\n    // eof/bof case, need to shift fetch index if bof\n    let fetchIndex = fetch.index;\n    if (items.length < fetch.count) {\n      if (cycle.innerLoop.isInitial) {\n        // let's treat initial poor fetch as startIndex-bof\n        fetchIndex = buffer.startIndex;\n      } else if (fetch.first.index < buffer.minIndex) { // normal bof\n        fetchIndex = buffer.minIndex - items.length;\n      }\n    }\n    fetch.items = items.map((item, index: number) =>\n      new Item(fetchIndex + index, item, scroller.routines)\n    );\n    return buffer.setItems(fetch.items);\n  }\n\n}\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\nimport { Item } from '../classes/item';\n\nexport default class Render extends BaseProcessFactory(CommonProcess.render) {\n\n  static run(scroller: Scroller): void {\n    const { workflow, state: { cycle, render, scroll }, viewport, routines } = scroller;\n    scroller.logger.stat('before new items render');\n    if (scroll.positionBeforeAsync === null) {\n      scroll.positionBeforeAsync = viewport.scrollPosition;\n    }\n    render.cancel = routines.render(() => {\n      render.cancel = null;\n      if (Render.doRender(scroller)) {\n        workflow.call({\n          process: Render.process,\n          status: render.noSize ? ProcessStatus.done : ProcessStatus.next,\n          payload: { process: cycle.initiator }\n        });\n      } else {\n        workflow.call({\n          process: Render.process,\n          status: ProcessStatus.error,\n          payload: { error: 'Can\\'t associate item with element' }\n        });\n      }\n    });\n  }\n\n  static doRender(scroller: Scroller): boolean {\n    const { state: { fetch, render }, viewport, buffer, logger } = scroller;\n    render.positionBefore = viewport.scrollPosition;\n    if (!fetch.isCheck) {\n      render.sizeBefore = viewport.getScrollableSize();\n      if (!fetch.items.every(item =>\n        Render.processElement(scroller, item)\n      )) {\n        return false;\n      }\n    }\n    buffer.checkDefaultSize();\n    render.sizeAfter = viewport.getScrollableSize();\n    logger.stat('after new items render');\n    logger.log(() => render.noSize ? 'viewport size has not been changed' : void 0);\n    return true;\n  }\n\n  static processElement(scroller: Scroller, item: Item): boolean {\n    const { viewport, buffer } = scroller;\n    const element = viewport.findItemElementById(item.nodeId);\n    if (!element) {\n      return false;\n    }\n    item.element = element as HTMLElement;\n    item.makeVisible();\n    item.setSize(buffer.getSizeByIndex(item.$index));\n    buffer.cacheItem(item);\n    return true;\n  }\n\n}\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\nimport { Direction } from '../inputs/index';\nimport { EMPTY_ITEM } from '../classes/adapter/props';\nimport { ScrollerWorkflow } from '../interfaces/index';\n\nconst isInterrupted = ({ call }: ScrollerWorkflow): boolean => !!call.interrupted;\n\nexport default class End extends BaseProcessFactory(CommonProcess.end) {\n\n  static run(scroller: Scroller, { error }: { error?: unknown } = {}): void {\n    const { workflow, state: { cycle: { interrupter } } } = scroller;\n\n    if (!error && !interrupter) {\n      // set out params accessible via Adapter\n      End.calculateParams(scroller, workflow);\n    }\n\n    // explicit interruption for we don't want to go through the inner loop finalizing\n    if (isInterrupted(workflow)) {\n      workflow.call({ process: End.process, status: ProcessStatus.done });\n      return;\n    }\n\n    const next = End.shouldContinueRun(scroller, error);\n    scroller.state.endInnerLoop();\n\n    workflow.call({\n      process: End.process,\n      status: next ? ProcessStatus.next : ProcessStatus.done,\n      payload: { ...(interrupter ? { process: interrupter } : {}) }\n    });\n  }\n\n  static calculateParams(scroller: Scroller, workflow: ScrollerWorkflow): void {\n    const { adapter, viewport, buffer: { items } } = scroller;\n\n    if (adapter.wanted.firstVisible) {\n      const { item } = viewport.getEdgeVisibleItem(items, Direction.backward);\n      if (!item || item.element !== adapter.firstVisible.element) {\n        adapter.firstVisible = item ? item.get() : EMPTY_ITEM;\n      }\n    }\n\n    // the workflow can be interrupter on firstVisible change\n    if (adapter.wanted.lastVisible && !isInterrupted(workflow)) {\n      const { item } = viewport.getEdgeVisibleItem(items, Direction.forward);\n      if (!item || item.element !== adapter.lastVisible.element) {\n        adapter.lastVisible = item ? item.get() : EMPTY_ITEM;\n      }\n    }\n  }\n\n  static shouldContinueRun(scroller: Scroller, error: unknown): boolean {\n    const { cycle, fetch, render } = scroller.state;\n    // Adapter.reload or Adapter.reset\n    if (cycle.interrupter) {\n      return true;\n    }\n    // critical error\n    if (error) {\n      return false;\n    }\n    // Adapter.check\n    if (fetch.simulate && fetch.isCheck && !render.noSize) {\n      return true;\n    }\n    // Adapter.remove or Adapter.update with clip\n    if (fetch.simulate && fetch.doRemove) {\n      return true;\n    }\n    // common inner loop (App start, scroll, Adapter.clip) with full fetch\n    if (!fetch.simulate && ((fetch.hasNewItems && !render.noSize) || fetch.hasAnotherPack)) {\n      return true;\n    }\n    return false;\n  }\n\n}\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\r\nimport { Scroller } from '../scroller';\r\nimport End from './end';\r\n\r\nexport default class Adjust extends BaseProcessFactory(CommonProcess.adjust) {\r\n\r\n  static run(scroller: Scroller): void {\r\n    const { workflow, viewport, state: { scroll } } = scroller;\r\n\r\n    scroll.positionBeforeAdjust = viewport.scrollPosition;\r\n    Adjust.setPaddings(scroller);\r\n    scroll.positionAfterAdjust = viewport.scrollPosition;\r\n\r\n    // scroll position adjustments\r\n    const position = Adjust.calculatePosition(scroller);\r\n\r\n    // additional adjustment if the position can't be reached during the initial cycle\r\n    Adjust.setAdditionalForwardPadding(scroller, position);\r\n\r\n    // set new position using animation frame\r\n    Adjust.setPosition(scroller, position, () =>\r\n      workflow.call({\r\n        process: Adjust.process,\r\n        status: ProcessStatus.done\r\n      })\r\n    );\r\n  }\r\n\r\n  static setPaddings(scroller: Scroller): void {\r\n    const { viewport, buffer, settings: { inverse }, state: { fetch } } = scroller;\r\n    const firstItem = buffer.getFirstVisibleItem();\r\n    const lastItem = buffer.getLastVisibleItem();\r\n    let first, last;\r\n    if (firstItem && lastItem) {\r\n      first = firstItem.$index;\r\n      last = lastItem.$index;\r\n    } else {\r\n      first = !isNaN(fetch.firstVisible.index) ? fetch.firstVisible.index : buffer.startIndex;\r\n      last = first - 1;\r\n    }\r\n    const { forward, backward } = viewport.paddings;\r\n    let index, bwdSize = 0, fwdSize = 0;\r\n\r\n    // new backward and forward paddings size\r\n    for (index = buffer.finiteAbsMinIndex; index < first; index++) {\r\n      bwdSize += buffer.getSizeByIndex(index);\r\n    }\r\n    for (index = last + 1; index <= buffer.finiteAbsMaxIndex; index++) {\r\n      fwdSize += buffer.getSizeByIndex(index);\r\n    }\r\n\r\n    // lack of items case\r\n    const bufferSize = viewport.getScrollableSize() - forward.size - backward.size;\r\n    const scrollSize = bwdSize + bufferSize + fwdSize;\r\n    const viewportSizeDiff = viewport.getSize() - scrollSize;\r\n    if (viewportSizeDiff > 0) {\r\n      if (inverse) {\r\n        bwdSize += viewportSizeDiff;\r\n      } else {\r\n        fwdSize += viewportSizeDiff;\r\n      }\r\n      scroller.logger.log(() =>\r\n        inverse ? 'backward' : 'forward' + ` padding will be increased by ${viewportSizeDiff} to fill the viewport`\r\n      );\r\n    }\r\n\r\n    backward.size = bwdSize;\r\n    forward.size = fwdSize;\r\n\r\n    scroller.logger.stat('after paddings adjustments');\r\n  }\r\n\r\n  static calculatePosition(scroller: Scroller): number {\r\n    const { viewport, buffer, state: { fetch, render, scroll } } = scroller;\r\n    let position = viewport.paddings.backward.size;\r\n\r\n    // increase the position to meet the expectation of the first visible item\r\n    if (!isNaN(fetch.firstVisible.index) && !isNaN(buffer.firstIndex)) {\r\n      scroller.logger.log(`first index = ${fetch.firstVisible.index}, delta = ${fetch.firstVisible.delta}`);\r\n      const shouldCheckPreSizeExpectation = fetch.shouldCheckPreSizeExpectation(buffer.lastIndex);\r\n      buffer.items.forEach(item => {\r\n        // 1) shift of the buffered items before the first visible item\r\n        if (item.$index < fetch.firstVisible.index) {\r\n          position += item.size;\r\n          return;\r\n        }\r\n        // 2) delta of the first visible item\r\n        if (item.$index === fetch.firstVisible.index && fetch.firstVisible.delta) {\r\n          position -= fetch.firstVisible.delta;\r\n        }\r\n        // 3) difference between expected and real sizes of fetched items after the first visible\r\n        if (shouldCheckPreSizeExpectation && item.preSize && fetch.items.includes(item)) {\r\n          position += item.size - item.preSize;\r\n        }\r\n      });\r\n    }\r\n\r\n    // slow fetch/render case\r\n    if (scroll.positionBeforeAsync !== null) {\r\n      const diff = render.positionBefore - scroll.positionBeforeAsync;\r\n      if (diff !== 0) {\r\n        scroller.logger.log(`shift position due to fetch-render difference (${diff})`);\r\n        position += diff;\r\n      }\r\n    }\r\n\r\n    // increase the position due to viewport's offset\r\n    if (viewport.offset > 0 && (position || fetch.positions.before)) {\r\n      position += viewport.offset;\r\n    }\r\n\r\n    return Math.round(position);\r\n  }\r\n\r\n  static setAdditionalForwardPadding(scroller: Scroller, position: number): void {\r\n    const { viewport, buffer, state: { cycle } } = scroller;\r\n    if (!cycle.isInitial || !End.shouldContinueRun(scroller, null)) {\r\n      return;\r\n    }\r\n    const diff = position - viewport.getMaxScrollPosition();\r\n    if (diff <= 0) {\r\n      return;\r\n    }\r\n    const last = buffer.getLastVisibleItem();\r\n    if (!last) {\r\n      return;\r\n    }\r\n    let size = 0;\r\n    let index = last.$index + 1;\r\n    while (size <= diff && index <= buffer.absMaxIndex) {\r\n      size += buffer.getSizeByIndex(index++);\r\n    }\r\n    const shift = Math.min(size, diff);\r\n    if (shift) {\r\n      viewport.paddings.forward.size += shift;\r\n      scroller.logger.log(`increase fwd padding due to lack of items (${diff} -> ${shift})`);\r\n    }\r\n  }\r\n\r\n  static setPosition(scroller: Scroller, position: number, done: () => void): void {\r\n    const { state: { scroll }, viewport, routines } = scroller;\r\n    if (!scroll.hasPositionChanged(position)) {\r\n      return done();\r\n    }\r\n    scroll.syntheticPosition = position;\r\n    scroll.syntheticFulfill = false;\r\n\r\n    scroll.cancelAnimation = routines.animate(() => {\r\n      scroll.cancelAnimation = null;\r\n      const inertiaDiff = (scroll.positionAfterAdjust as number) - viewport.scrollPosition;\r\n      let diffLog = '';\r\n      if (inertiaDiff > 0) {\r\n        position -= inertiaDiff;\r\n        scroll.syntheticPosition = position;\r\n        diffLog = ` (-${inertiaDiff})`;\r\n      }\r\n      scroll.syntheticFulfill = true;\r\n      viewport.scrollPosition = position;\r\n      scroller.logger.stat('after scroll adjustment' + diffLog);\r\n      done();\r\n    });\r\n  }\r\n\r\n}\r\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\nimport { Direction } from '../inputs/index';\n\nexport default class PreClip extends BaseProcessFactory(CommonProcess.preClip) {\n\n  static run(scroller: Scroller): void {\n    PreClip.prepareClip(scroller);\n\n    scroller.workflow.call({\n      process: PreClip.process,\n      status: ProcessStatus.next,\n      payload: {\n        doClip: scroller.state.clip.doClip\n      }\n    });\n  }\n\n  static prepareClip(scroller: Scroller): void {\n    const { state: { fetch, clip } } = scroller;\n    if (PreClip.shouldNotClip(scroller)) {\n      return;\n    }\n    const firstIndex = fetch.first.indexBuffer;\n    const lastIndex = fetch.last.indexBuffer;\n    scroller.logger.log(() =>\n      `looking for ${fetch.direction ? 'anti-' + fetch.direction + ' ' : ''}items ` +\n      `that are out of [${firstIndex}..${lastIndex}] range`);\n    if (PreClip.isBackward(scroller, firstIndex)) {\n      PreClip.prepareClipByDirection(scroller, Direction.backward, firstIndex);\n    }\n    if (PreClip.isForward(scroller, lastIndex)) {\n      PreClip.prepareClipByDirection(scroller, Direction.forward, lastIndex);\n    }\n    if (!clip.doClip) {\n      scroller.logger.log('skipping clip [no items to clip]');\n    }\n    return;\n  }\n\n  static shouldNotClip(scroller: Scroller): boolean {\n    const { settings, buffer, state } = scroller;\n    if (settings.infinite && !state.clip.force) {\n      scroller.logger.log('skipping clip [infinite mode]');\n      return true;\n    }\n    if (!buffer.size) {\n      scroller.logger.log('skipping clip [empty buffer]');\n      return true;\n    }\n    if (state.cycle.isInitial) {\n      scroller.logger.log('skipping clip [initial cycle]');\n      return true;\n    }\n    return false;\n  }\n\n  static isBackward(scroller: Scroller, firstIndex: number): boolean {\n    const { buffer, state: { clip, fetch } } = scroller;\n    if (clip.force) {\n      return clip.forceBackward;\n    }\n    if (fetch.direction !== Direction.backward) {\n      if (firstIndex - 1 >= buffer.absMinIndex) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  static isForward(scroller: Scroller, lastIndex: number): boolean {\n    const { buffer, state: { clip, fetch } } = scroller;\n    if (clip.force) {\n      return clip.forceForward;\n    }\n    if (fetch.direction !== Direction.forward) {\n      if (lastIndex + 1 <= buffer.absMaxIndex) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  static prepareClipByDirection(scroller: Scroller, direction: Direction, edgeIndex: number): void {\n    const forward = direction === Direction.forward;\n    scroller.buffer.items.forEach(item => {\n      if (\n        (!forward && item.$index < edgeIndex) ||\n        (forward && item.$index > edgeIndex)\n      ) {\n        item.toRemove = true;\n        item.removeDirection = direction;\n        scroller.state.clip.doClip = true;\n      }\n    });\n  }\n\n}\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\r\nimport { Scroller } from '../scroller';\r\nimport { Direction } from '../inputs/index';\r\n\r\nexport default class Clip extends BaseProcessFactory(CommonProcess.clip) {\r\n\r\n  static run(scroller: Scroller): void {\r\n    const { workflow } = scroller;\r\n\r\n    Clip.doClip(scroller);\r\n\r\n    workflow.call({\r\n      process: Clip.process,\r\n      status: ProcessStatus.next\r\n    });\r\n  }\r\n\r\n  static doClip(scroller: Scroller): void {\r\n    const { buffer, viewport: { paddings }, state: { clip }, logger } = scroller;\r\n    const size = { [Direction.backward]: 0, [Direction.forward]: 0 };\r\n\r\n    logger.stat(`before clip (${++clip.callCount})`);\r\n\r\n    const itemsToRemove = buffer.items.filter(item => {\r\n      if (!item.toRemove) {\r\n        return false;\r\n      }\r\n      item.hide();\r\n      size[item.removeDirection] += item.size;\r\n      return true;\r\n    });\r\n\r\n    if (itemsToRemove.length) {\r\n      if (size[Direction.backward]) {\r\n        paddings.byDirection(Direction.backward).size += size[Direction.backward];\r\n      }\r\n      if (size[Direction.forward]) {\r\n        paddings.byDirection(Direction.forward).size += size[Direction.forward];\r\n      }\r\n      if (scroller.settings.onBeforeClip) {\r\n        scroller.settings.onBeforeClip(itemsToRemove.map(item => item.get()));\r\n      }\r\n    }\r\n\r\n    buffer.clip();\r\n\r\n    logger.log(() => {\r\n      const list = itemsToRemove.map(({ $index }) => $index);\r\n      return list.length\r\n        ? [\r\n          `clipped ${list.length} item(s) from Buffer` +\r\n          (size.backward ? `, +${size.backward} fwd px` : '') +\r\n          (size.forward ? `, +${size.forward} bwd px` : '') +\r\n          `, range: [${list[0]}..${list[list.length - 1]}]`\r\n        ]\r\n        : 'clipped 0 items from Buffer';\r\n    });\r\n\r\n    logger.stat('after clip');\r\n  }\r\n\r\n}\r\n","import { Scroller } from '../scroller';\nimport { CommonProcess, AdapterProcess, ProcessStatus as Status } from '../processes/index';\nimport { IPackages, ProcessSubject } from '../interfaces/index';\n\ntype LogType = [unknown?, ...unknown[]];\n\nexport class Logger {\n\n  readonly debug: boolean;\n  readonly immediateLog: boolean;\n  readonly logTime: boolean;\n  readonly getTime: () => string;\n  readonly getStat: () => string;\n  readonly getFetchRange: () => string;\n  readonly getWorkflowCycleData: () => string;\n  readonly getLoopId: () => string;\n  readonly getLoopIdNext: () => string;\n  readonly getScrollPosition: () => number;\n  private logs: unknown[][] = [];\n\n  constructor(scroller: Scroller, packageInfo: IPackages, adapter?: { id: number }) {\n    const { settings } = scroller;\n    this.debug = settings.debug;\n    this.immediateLog = settings.immediateLog;\n    this.logTime = settings.logTime;\n    this.getTime = (): string =>\n      scroller.state && ` // time: ${scroller.state.time}`;\n    this.getStat = (): string => {\n      const { buffer, viewport } = scroller;\n      const first = buffer.getFirstVisibleItem();\n      const last = buffer.getLastVisibleItem();\n      return 'pos: ' + viewport.scrollPosition + ', ' +\n        'size: ' + viewport.getScrollableSize() + ', ' +\n        'bwd_p: ' + viewport.paddings.backward.size + ', ' +\n        'fwd_p: ' + viewport.paddings.forward.size + ', ' +\n        'default: ' + (buffer.defaultSize || 'no') + ', ' +\n        'items: ' + buffer.getVisibleItemsCount() + ', ' +\n        'range: ' + (first && last ? `[${first.$index}..${last.$index}]` : 'no');\n    };\n    this.getFetchRange = (): string => {\n      const { first: { index: first }, last: { index: last } } = scroller.state.fetch;\n      return !Number.isNaN(first) && !Number.isNaN(last)\n        ? `[${first}..${last}]`\n        : 'no';\n    };\n    this.getLoopId = (): string => scroller.state.cycle.loopId;\n    this.getLoopIdNext = (): string => scroller.state.cycle.loopIdNext;\n    this.getWorkflowCycleData = (): string =>\n      `${settings.instanceIndex}-${scroller.state.cycle.count}`;\n    this.getScrollPosition = () => scroller.routines.getScrollPosition();\n    this.log(() =>\n      'vscroll Workflow has been started, ' +\n      `core: ${packageInfo.core.name} v${packageInfo.core.version}, ` +\n      `consumer: ${packageInfo.consumer.name} v${packageInfo.consumer.version}, ` +\n      `scroller instance: ${settings.instanceIndex}, adapter ` +\n      (!adapter ? 'is not instantiated' : `instance: ${adapter.id}`)\n    );\n  }\n\n  object(str: string, obj: unknown, stringify?: boolean): void {\n    this.log(() => [\n      str,\n      stringify\n        ? JSON.stringify(obj, (k, v) => {\n          if (Number.isNaN(v)) {\n            return 'NaN';\n          }\n          if (v === Infinity) {\n            return 'Infinity';\n          }\n          if (v === -Infinity) {\n            return '-Infinity';\n          }\n          if (v instanceof Element) {\n            return 'HTMLElement';\n          }\n          if (v instanceof HTMLDocument) {\n            return 'HTMLDocument';\n          }\n          if (typeof v === 'function') {\n            return 'Function';\n          }\n          return v;\n        })\n          .replace(/\"/g, '')\n          .replace(/(\\{|:|,)/g, '$1 ')\n          .replace(/(\\})/g, ' $1')\n        : obj\n    ]);\n  }\n\n  stat(str?: string): void {\n    if (this.debug) {\n      const logStyles = [\n        'color: #888; border: dashed #888 0; border-bottom-width: 0px',\n        'color: #000; border-width: 0'\n      ];\n      this.log(() => ['%cstat' + (str ? ` ${str}` : '') + ',%c ' + this.getStat(), ...logStyles]);\n    }\n  }\n\n  fetch(str?: string): void {\n    if (this.debug) {\n      const _text = 'fetch interval' + (str ? ` ${str}` : '');\n      const logStyles = ['color: #888', 'color: #000'];\n      this.log(() => [`%c${_text}: %c${this.getFetchRange()}`, ...logStyles]);\n    }\n  }\n\n  prepareForLog(data: unknown): unknown {\n    return data instanceof Event && data.target\n      ? this.getScrollPosition()\n      : data;\n  }\n\n  logProcess(data: ProcessSubject): void {\n    if (!this.debug) {\n      return;\n    }\n    const { process, status, payload } = data;\n\n    // inner loop start-end log\n    const loopLog: string[] = [];\n    if (\n      process === CommonProcess.init && status === Status.next\n    ) {\n      loopLog.push(`%c---=== loop ${this.getLoopIdNext()} start`);\n    } else if (\n      process === CommonProcess.end\n    ) {\n      loopLog.push(`%c---=== loop ${this.getLoopId()} done`);\n      const parent = payload && payload.process;\n      if (status === Status.next && (parent !== AdapterProcess.reset && parent !== AdapterProcess.reload)) {\n        loopLog[0] += `, loop ${this.getLoopIdNext()} start`;\n      }\n    }\n    if (loopLog.length) {\n      this.log(() => [...loopLog, 'color: #006600;']);\n    }\n  }\n\n  logCycle(start = true): void {\n    const logData = this.getWorkflowCycleData();\n    const border = start ? '1px 0 0 1px' : '0 0 1px 1px';\n    const logStyles = `color: #0000aa; border: solid #555 1px; border-width: ${border}; margin-left: -2px`;\n    this.log(() => [`%c   ~~~ WF Cycle ${logData} ${start ? 'STARTED' : 'FINALIZED'} ~~~  `, logStyles]);\n  }\n\n  logError(str: string): void {\n    if (this.debug) {\n      const logStyles = ['color: #a00;', 'color: #000'];\n      this.log(() => ['error:%c' + (str ? ` ${str}` : '') + `%c (loop ${this.getLoopIdNext()})`, ...logStyles]);\n    }\n  }\n\n  logAdapterMethod = (methodName: string, args?: unknown, add?: string): void => {\n    if (!this.debug) {\n      return;\n    }\n    const params = (\n      args === void 0 ? [] : (Array.isArray(args) ? args : [args])\n    )\n      .map((arg: unknown) => {\n        if (typeof arg === 'function') {\n          return 'func';\n        } else if (typeof arg !== 'object' || !arg) {\n          return arg;\n        } else if (Array.isArray(arg)) {\n          return `[of ${arg.length}]`;\n        }\n        return '{ ' + Object.keys(arg).join(', ') + ' }';\n      })\n      .join(', ');\n    this.log(`adapter: ${methodName}(${params || ''})${add || ''}`);\n  };\n\n  log(...args: any[]): void {\n    if (this.debug) {\n      if (typeof args[0] === 'function') {\n        args = args[0]();\n        if (!Array.isArray(args)) {\n          args = [args];\n        }\n      }\n      if (args.every(item => item === void 0)) {\n        return;\n      }\n      if (this.logTime) {\n        args = [...args, this.getTime()];\n      }\n      args = args.map((arg: unknown) => this.prepareForLog(arg));\n      if (this.immediateLog) {\n        console.log.apply(this, args as LogType);\n      } else {\n        this.logs.push(args);\n      }\n    }\n  }\n\n  // logNow(...args: any[]) {\n  //   const immediateLog = this.immediateLog;\n  //   const debug = this.debug;\n  //   (this as any).debug = true;\n  //   (this as any).immediateLog = true;\n  //   this.log.apply(this, args);\n  //   (this as any).debug = debug;\n  //   (this as any).immediateLog = immediateLog;\n  // }\n\n  logForce(...args: unknown[]): void {\n    if (this.debug) {\n      if (!this.immediateLog && this.logs.length) {\n        this.logs.forEach(logArgs => console.log.apply(this, logArgs));\n        this.logs = [];\n      }\n      if (args.length) {\n        console.log.apply(this, args as LogType);\n      }\n    }\n  }\n}\n","import { Settings } from './settings';\nimport { Direction } from '../inputs/index';\nimport { IRoutines, CustomRoutinesClass } from '../interfaces/index';\n\nexport class Routines implements IRoutines {\n\n  readonly settings: IRoutines['settings'];\n  readonly element: HTMLElement;\n  readonly viewport: HTMLElement;\n\n  constructor(element: HTMLElement, settings: Settings, CustomRoutines?: CustomRoutinesClass) {\n    this.element = element;\n    this.settings = {\n      viewport: settings.viewport,\n      horizontal: settings.horizontal,\n      window: settings.windowViewport\n    };\n    // provide custom overrides for IRoutines methods\n    if (CustomRoutines) {\n      const routines = new CustomRoutines(element, this.settings);\n      Object.getOwnPropertyNames(Object.getPrototypeOf(routines))\n        .filter(method =>\n          method !== 'constructor' &&\n          typeof routines[method] === 'function' &&\n          typeof this[method] === 'function'\n        )\n        .forEach(method =>\n          this[method] = (...args: unknown[]) =>\n            routines[method].apply(this, args)\n        );\n    }\n    // initialization\n    this.viewport = this.getViewportElement();\n    this.onInit(settings);\n  }\n\n  checkElement(element: HTMLElement): void {\n    if (!element) {\n      throw new Error('HTML element is not defined');\n    }\n  }\n\n  getViewportElement(): HTMLElement {\n    if (this.settings.window) {\n      return document.documentElement;\n    }\n    if (this.settings.viewport) {\n      return this.settings.viewport;\n    }\n    this.checkElement(this.element);\n    const parent = this.element.parentElement as HTMLElement;\n    this.checkElement(parent);\n    return parent;\n  }\n\n  onInit(settings: Settings): void {\n    if (settings.windowViewport) {\n      if ('scrollRestoration' in history) {\n        history.scrollRestoration = 'manual';\n      }\n    }\n    if (settings.dismissOverflowAnchor) {\n      this.viewport.style.overflowAnchor = 'none';\n    }\n  }\n\n  findElementBySelector(element: HTMLElement, selector: string): HTMLElement | null {\n    this.checkElement(element);\n    return element.querySelector(selector);\n  }\n\n  findPaddingElement(direction: Direction): HTMLElement | null {\n    return this.findElementBySelector(this.element, `[data-padding-${direction}]`);\n  }\n\n  findItemElement(id: string): HTMLElement | null {\n    return this.findElementBySelector(this.element, `[data-sid=\"${id}\"]`);\n  }\n\n  getScrollPosition(): number {\n    if (this.settings.window) {\n      return this.settings.horizontal ? window.pageXOffset : window.pageYOffset;\n    }\n    return this.viewport[this.settings.horizontal ? 'scrollLeft' : 'scrollTop'];\n  }\n\n  setScrollPosition(value: number): void {\n    value = Math.max(0, value);\n    if (this.settings.window) {\n      if (this.settings.horizontal) {\n        window.scrollTo(value, window.scrollY);\n      } else {\n        window.scrollTo(window.scrollX, value);\n      }\n      return;\n    }\n    this.viewport[this.settings.horizontal ? 'scrollLeft' : 'scrollTop'] = value;\n  }\n\n  getElementParams(element: HTMLElement): DOMRect {\n    this.checkElement(element);\n    return element.getBoundingClientRect();\n  }\n\n  getWindowParams(): DOMRect {\n    const { clientWidth, clientHeight, clientLeft, clientTop } = this.viewport;\n    return {\n      'height': clientHeight,\n      'width': clientWidth,\n      'top': clientTop,\n      'bottom': clientTop + clientHeight,\n      'left': clientLeft,\n      'right': clientLeft + clientWidth,\n      'x': clientLeft,\n      'y': clientTop,\n      'toJSON': () => null,\n    };\n  }\n\n  getSize(element: HTMLElement): number {\n    return this.getElementParams(element)[this.settings.horizontal ? 'width' : 'height'];\n  }\n\n  getScrollerSize(): number {\n    return this.getElementParams(this.element)[this.settings.horizontal ? 'width' : 'height'];\n  }\n\n  getViewportSize(): number {\n    if (this.settings.window) {\n      return this.getWindowParams()[this.settings.horizontal ? 'width' : 'height'];\n    }\n    return this.getSize(this.viewport);\n  }\n\n  getSizeStyle(element: HTMLElement): number {\n    this.checkElement(element);\n    const size = element.style[this.settings.horizontal ? 'width' : 'height'];\n    return parseFloat(size as string) || 0;\n  }\n\n  setSizeStyle(element: HTMLElement, value: number): void {\n    this.checkElement(element);\n    value = Math.max(0, Math.round(value));\n    element.style[this.settings.horizontal ? 'width' : 'height'] = `${value}px`;\n  }\n\n  getEdge(element: HTMLElement, direction: Direction): number {\n    const { horizontal } = this.settings;\n    const params = this.getElementParams(element);\n    const isFwd = direction === Direction.forward;\n    return params[isFwd ? (horizontal ? 'right' : 'bottom') : (horizontal ? 'left' : 'top')];\n  }\n\n  getViewportEdge(direction: Direction): number {\n    const { window, horizontal } = this.settings;\n    if (window) {\n      const params = this.getWindowParams();\n      const isFwd = direction === Direction.forward;\n      return params[isFwd ? (horizontal ? 'right' : 'bottom') : (horizontal ? 'left' : 'top')];\n    }\n    return this.getEdge(this.viewport, direction);\n  }\n\n  makeElementVisible(element: HTMLElement): void {\n    this.checkElement(element);\n    element.style.left = '';\n    element.style.top = '';\n    element.style.position = '';\n  }\n\n  hideElement(element: HTMLElement): void {\n    this.checkElement(element);\n    element.style.display = 'none';\n  }\n\n  getOffset(): number {\n    const get = (element: HTMLElement) =>\n      (this.settings.horizontal ? element.offsetLeft : element.offsetTop) || 0;\n    return get(this.element) - (!this.settings.window ? get(this.viewport) : 0);\n  }\n\n  scrollTo(element: HTMLElement, argument?: boolean | ScrollIntoViewOptions): void {\n    this.checkElement(element);\n    element.scrollIntoView(argument);\n  }\n\n  render(cb: () => void): () => void {\n    const timeoutId = setTimeout(() => cb());\n    return () => clearTimeout(timeoutId);\n  }\n\n  animate(cb: () => void): () => void {\n    const animationFrameId = requestAnimationFrame(() => cb());\n    return () => cancelAnimationFrame(animationFrameId);\n  }\n\n  onScroll(handler: EventListener): () => void {\n    const eventReceiver = this.settings.window ? window : this.viewport;\n    eventReceiver.addEventListener('scroll', handler);\n    return () => eventReceiver.removeEventListener('scroll', handler);\n  }\n\n}\n","import { Routines } from './domRoutines';\r\nimport { Settings } from './settings';\r\nimport { Direction } from '../inputs/index';\r\n\r\nexport class Padding {\r\n\r\n  element: HTMLElement;\r\n  direction: Direction;\r\n  routines: Routines;\r\n\r\n  constructor(direction: Direction, routines: Routines) {\r\n    const found = routines.findPaddingElement(direction);\r\n    routines.checkElement(found as HTMLElement);\r\n    this.element = found as HTMLElement;\r\n    this.direction = direction;\r\n    this.routines = routines;\r\n  }\r\n\r\n  reset(size?: number): void {\r\n    this.size = size || 0;\r\n  }\r\n\r\n  get size(): number {\r\n    return this.routines.getSizeStyle(this.element);\r\n  }\r\n\r\n  set size(value: number) {\r\n    this.routines.setSizeStyle(this.element, value);\r\n  }\r\n\r\n}\r\n\r\nexport class Paddings {\r\n  settings: Settings;\r\n  forward: Padding;\r\n  backward: Padding;\r\n\r\n  constructor(routines: Routines, settings: Settings) {\r\n    this.settings = settings;\r\n    this.forward = new Padding(Direction.forward, routines);\r\n    this.backward = new Padding(Direction.backward, routines);\r\n  }\r\n\r\n  byDirection(direction: Direction, opposite?: boolean): Padding {\r\n    return direction === Direction.backward\r\n      ? (opposite ? this.forward : this.backward)\r\n      : (opposite ? this.backward : this.forward);\r\n  }\r\n\r\n  reset(viewportSize: number, startIndex: number, offset: number): void {\r\n    const positive = this.getPositiveSize(startIndex, viewportSize, offset);\r\n    const negative = this.getNegativeSize(startIndex);\r\n    if (this.settings.inverse) {\r\n      this.forward.reset(negative);\r\n      this.backward.reset(positive);\r\n      const diff = viewportSize - this.backward.size - offset;\r\n      if (diff > 0) {\r\n        this.backward.size += diff;\r\n        this.forward.size -= diff;\r\n      }\r\n    } else {\r\n      this.forward.reset(positive);\r\n      this.backward.reset(negative);\r\n      const diff = viewportSize - this.forward.size - offset;\r\n      if (diff > 0) {\r\n        this.backward.size -= diff;\r\n        this.forward.size += diff;\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  getPositiveSize(startIndex: number, viewportSize: number, offset: number): number {\r\n    const { settings } = this;\r\n    let positiveSize = viewportSize;\r\n    if (isFinite(settings.maxIndex)) {\r\n      positiveSize = (settings.maxIndex - startIndex + 1) * settings.itemSize;\r\n    }\r\n    if (offset) {\r\n      positiveSize = Math.max(positiveSize - offset, 0);\r\n    }\r\n    return positiveSize;\r\n  }\r\n\r\n  getNegativeSize(startIndex: number): number {\r\n    const { settings } = this;\r\n    let negativeSize = 0;\r\n    if (isFinite(settings.minIndex)) {\r\n      negativeSize = (startIndex - settings.minIndex) * settings.itemSize;\r\n    }\r\n    return negativeSize;\r\n  }\r\n}\r\n","import { Paddings } from './paddings';\nimport { Settings } from './settings';\nimport { Routines } from './domRoutines';\nimport { Item } from './item';\nimport { State } from './state';\nimport { Logger } from './logger';\nimport { Direction } from '../inputs/index';\n\nexport class Viewport {\n\n  offset: number;\n  paddings: Paddings;\n\n  readonly settings: Settings;\n  readonly routines: Routines;\n  readonly state: State;\n  readonly logger: Logger;\n\n  constructor(settings: Settings, routines: Routines, state: State, logger: Logger) {\n    this.settings = settings;\n    this.routines = routines;\n    this.state = state;\n    this.logger = logger;\n    this.paddings = new Paddings(this.routines, settings);\n  }\n\n  reset(startIndex: number): void {\n    this.setOffset();\n    this.paddings.reset(this.getSize(), startIndex, this.offset);\n    this.scrollPosition = this.paddings.backward.size || 0;\n    this.state.scroll.reset();\n  }\n\n  setPosition(value: number): number {\n    const oldPosition = this.scrollPosition;\n    if (oldPosition === value) {\n      this.logger.log(() => ['setting scroll position at', value, '[cancelled]']);\n      return value;\n    }\n    this.routines.setScrollPosition(value);\n    const position = this.scrollPosition;\n    this.logger.log(() => [\n      'setting scroll position at', position, ...(position !== value ? [`(${value})`] : [])\n    ]);\n    return position;\n  }\n\n  get scrollPosition(): number {\n    return this.routines.getScrollPosition();\n  }\n\n  set scrollPosition(value: number) {\n    this.setPosition(value);\n  }\n\n  getSize(): number {\n    return this.routines.getViewportSize();\n  }\n\n  getScrollableSize(): number {\n    return this.routines.getScrollerSize();\n  }\n\n  getMaxScrollPosition(): number {\n    return this.getScrollableSize() - this.getSize();\n  }\n\n  getBufferPadding(): number {\n    return this.getSize() * this.settings.padding;\n  }\n\n  getEdge(direction: Direction): number {\n    return this.routines.getViewportEdge(direction);\n  }\n\n  setOffset(): void {\n    this.offset = this.routines.getOffset();\n  }\n\n  findItemElementById(id: string): HTMLElement | null {\n    return this.routines.findItemElement(id);\n  }\n\n  getEdgeVisibleItem(items: Item[], direction: Direction): { item?: Item, index: number, diff: number } {\n    const bwd = direction === Direction.backward;\n    const opposite = bwd ? Direction.forward : Direction.backward;\n    const viewportEdge = this.getEdge(direction);\n    let item, diff = 0;\n    for (\n      let i = bwd ? 0 : items.length - 1;\n      bwd ? i <= items.length - 1 : i >= 0;\n      i += bwd ? 1 : -1\n    ) {\n      const itemEdge = this.routines.getEdge(items[i].element, opposite);\n      diff = itemEdge - viewportEdge;\n      if (bwd && diff > 0 || !bwd && diff < 0) {\n        item = items[i];\n        break;\n      }\n    }\n    return { item, index: item ? item.$index : NaN, diff };\n  }\n\n}\n","import { SizeStrategy } from '../../inputs/index';\n\ninterface ItemSize {\n  size: number;\n  newSize?: number;\n}\n\nexport class SizesRecalculation {\n  newItems: ItemSize[];\n  oldItems: ItemSize[];\n  removed: ItemSize[];\n\n  constructor() {\n    this.reset();\n  }\n\n  reset(): void {\n    this.newItems = [];\n    this.oldItems = [];\n    this.removed = [];\n  }\n}\n\nexport class DefaultSize {\n  private readonly itemSize: number;\n  private readonly sizeStrategy: SizeStrategy;\n  private sizeMap: Map<number, number>;\n  private recalculation: SizesRecalculation;\n\n  private constantSize: number;\n  private frequentSize: number;\n  private averageSize: number;\n  private averageSizeFloat: number;\n\n  constructor(itemSize: number, sizeStrategy: SizeStrategy) {\n    this.itemSize = itemSize;\n    this.sizeStrategy = sizeStrategy;\n    this.sizeMap = new Map<number, number>();\n    this.recalculation = new SizesRecalculation();\n  }\n\n  reset(force: boolean): void {\n    if (force) {\n      this.constantSize = this.itemSize;\n      this.frequentSize = this.itemSize;\n      this.averageSize = this.itemSize;\n      this.averageSizeFloat = this.itemSize;\n      this.sizeMap.clear();\n    }\n    this.recalculation.reset();\n  }\n\n  get(): number {\n    switch (this.sizeStrategy) {\n      case SizeStrategy.Average:\n        return this.averageSize;\n      case SizeStrategy.Frequent:\n        return this.frequentSize;\n      default:\n        return this.constantSize;\n    }\n  }\n\n  private recalculateAverageSize(cacheSize: number): void {\n    const { oldItems, newItems, removed } = this.recalculation;\n    if (oldItems.length) {\n      const oldSize = oldItems.reduce((acc, item) => acc + item.size, 0);\n      const newSize = oldItems.reduce((acc, item) => acc + (item.newSize as number), 0);\n      const averageSize = this.averageSizeFloat || 0;\n      this.averageSizeFloat = averageSize - (oldSize - newSize) / (cacheSize - newItems.length);\n    }\n    if (newItems.length) {\n      const newSize = newItems.reduce((acc, item) => acc + item.size, 0);\n      const averageSize = this.averageSizeFloat || 0;\n      this.averageSizeFloat = ((cacheSize - newItems.length) * averageSize + newSize) / cacheSize;\n    }\n    if (removed.length) {\n      const removedSize = removed.reduce((acc, item) => acc + item.size, 0);\n      const averageSize = this.averageSizeFloat || 0;\n      this.averageSizeFloat = ((cacheSize + removed.length) * averageSize - removedSize) / cacheSize;\n    }\n    this.averageSize = Math.round(this.averageSizeFloat);\n  }\n\n  private recalculateFrequentSize(): void {\n    const { oldItems, newItems, removed } = this.recalculation;\n    const oldFrequentSizeCount = this.sizeMap.get(this.frequentSize);\n    if (newItems.length) {\n      newItems.forEach(({ size }) => this.sizeMap.set(size, (this.sizeMap.get(size) || 0) + 1));\n    }\n    if (oldItems.length) {\n      oldItems.forEach(({ size }) => this.sizeMap.set(size, Math.max((this.sizeMap.get(size) || 0) - 1, 0)));\n      oldItems.forEach(({ newSize: s }) => this.sizeMap.set(s as number, (this.sizeMap.get(s as number) || 0) + 1));\n    }\n    if (removed.length) {\n      removed.forEach(({ size }) => this.sizeMap.set(size, Math.max((this.sizeMap.get(size) || 0) - 1, 0)));\n    }\n    const sorted = [...this.sizeMap.entries()].sort((a, b) => b[1] - a[1]);\n    const mostFrequentCount = sorted[0][1];\n    const listEqual = sorted.filter(i => i[1] === mostFrequentCount);\n    if (listEqual.length > 1 && listEqual.find(i => i[0] === oldFrequentSizeCount)) {\n      // if there are more than 1 most frequent sizes, but the old one is present\n      return;\n    }\n    this.frequentSize = sorted[0][0];\n  }\n\n  recalculate(cacheSize: number): boolean {\n    if (this.sizeStrategy === SizeStrategy.Constant) {\n      return false;\n    }\n    const { oldItems, newItems, removed } = this.recalculation;\n    if (!oldItems.length && !newItems.length && !removed.length) {\n      return false;\n    }\n    const oldValue = this.get();\n    if (!cacheSize) {\n      this.reset(true);\n    } else {\n      if (this.sizeStrategy === SizeStrategy.Average) {\n        this.recalculateAverageSize(cacheSize);\n      } else {\n        this.recalculateFrequentSize();\n      }\n      this.recalculation.reset();\n    }\n    return this.get() !== oldValue;\n  }\n\n  setExisted(oldSize: number, newSize: number): void {\n    if (this.sizeStrategy !== SizeStrategy.Constant) {\n      this.recalculation.oldItems.push({\n        size: oldSize,\n        newSize\n      });\n    }\n  }\n\n  setNew(size: number): void {\n    if (this.sizeStrategy !== SizeStrategy.Constant) {\n      this.recalculation.newItems.push({ size });\n    } else {\n      if (!this.constantSize) {\n        this.constantSize = size;\n      }\n    }\n  }\n\n  setRemoved(size: number): void {\n    if (this.sizeStrategy !== SizeStrategy.Constant) {\n      this.recalculation.removed.push({ size });\n    }\n  }\n}\n","import { DefaultSize } from './defaultSize';\nimport { Item } from '../item';\nimport { Settings } from '../settings';\nimport { Logger } from '../logger';\nimport { SizeStrategy, Direction } from '../../inputs/index';\n\ninterface ItemToCache<Data> {\n  $index: number;\n  data: Data;\n  size?: number;\n}\n\ninterface ItemUpdate {\n  $index: number;\n  size: number;\n  toRemove?: boolean;\n}\n\nexport class ItemCache<Data = unknown> {\n  $index: number;\n  data: Data | null;\n  size?: number;\n  position: number;\n\n  constructor(item: ItemToCache<Data>, saveData: boolean) {\n    this.$index = item.$index;\n    this.data = saveData ? item.data : null;\n    this.size = item.size;\n  }\n\n  changeIndex(value: number): void {\n    this.$index = value;\n  }\n}\n\nexport class Cache<Data = unknown> {\n  minIndex: number;\n  maxIndex: number;\n\n  readonly itemSize: number;\n  readonly saveData: boolean;\n  readonly cacheOnReload: boolean;\n  readonly sizeStrategy: SizeStrategy;\n  readonly logger: Logger;\n  private items: Map<number, ItemCache<Data>>;\n  private defaultSize: DefaultSize;\n\n  constructor({ itemSize, cacheData, cacheOnReload, sizeStrategy }: Settings, logger: Logger) {\n    this.itemSize = itemSize;\n    this.saveData = cacheData;\n    this.cacheOnReload = cacheOnReload;\n    this.sizeStrategy = sizeStrategy;\n    this.logger = logger;\n    this.items = new Map<number, ItemCache<Data>>();\n    this.defaultSize = new DefaultSize(itemSize, sizeStrategy);\n    this.reset(true);\n  }\n\n  reset(force: boolean): void {\n    force = force || !this.cacheOnReload;\n    if (force) {\n      this.minIndex = +Infinity;\n      this.maxIndex = -Infinity;\n      this.items.clear();\n    }\n    this.defaultSize.reset(force);\n  }\n\n  get size(): number {\n    return this.items.size;\n  }\n\n  get(index: number): ItemCache<Data> | undefined {\n    return this.items.get(index);\n  }\n\n  getSizeByIndex(index: number): number {\n    const item = this.get(index);\n    return item && item.size || this.defaultSize.get();\n  }\n\n  getDefaultSize(): number {\n    return this.defaultSize.get();\n  }\n\n  recalculateDefaultSize(): boolean {\n    if (this.defaultSize.recalculate(this.size)) {\n      this.logger.log(() => `default size has been updated: ${this.defaultSize.get()}`);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Adds item to Set by $index, replaces existed item if $index matches.\n   * Maintains min/max indexes and default item size.\n   *\n   * @param {Item<Data>} item A Buffer item to be cached, an objects with { $index, data, size } props.\n   * \n   * @returns {ItemCache<Data>} Cached item.\n   */\n  add(item: Item<Data>): ItemCache<Data> {\n    let itemCache = this.get(item.$index);\n    if (itemCache) { // adding item is already cached\n      if (this.saveData) {\n        itemCache.data = item.data;\n      }\n      if (itemCache.size !== item.size) {\n        if (itemCache.size) {\n          this.defaultSize.setExisted(itemCache.size, item.size);\n        } else {\n          this.defaultSize.setNew(item.size);\n        }\n        itemCache.size = item.size;\n      }\n    } else {\n      itemCache = new ItemCache<Data>(item, this.saveData);\n      this.items.set(item.$index, itemCache);\n      this.defaultSize.setNew(item.size);\n    }\n    if (item.$index < this.minIndex) {\n      this.minIndex = item.$index;\n    }\n    if (item.$index > this.maxIndex) {\n      this.maxIndex = item.$index;\n    }\n    return itemCache;\n  }\n\n  /**\n   * Inserts items to Set, shifts $indexes of items that remain.\n   * Replaces current Set with a new one with new regular $indexes.\n   * Maintains min/max indexes.\n   *\n   * @param {Data[]} toInsert List of non-indexed items to be inserted.\n   * @param {number} index The index before/after which the insertion is performed.\n   * @param {Direction} direction Determines the direction of insertion.\n   * @param {boolean} fixRight Defines indexes shifting strategy.\n   * If false, indexes that are greater than the inserted ones are increased.\n   * If true, indexes that are less than than the inserted ones are decreased.\n   */\n  insertItems(toInsert: Data[], index: number, direction: Direction, fixRight: boolean): void {\n    const items = new Map<number, ItemCache<Data>>();\n    const length = toInsert.length;\n    let min = Infinity, max = -Infinity;\n    const set = (item: ItemCache<Data>) => {\n      items.set(item.$index, item);\n      min = item.$index < min ? item.$index : min;\n      max = item.$index > max ? item.$index : max;\n    };\n    this.items.forEach(item => {\n      let shift = 0;\n      if (direction === Direction.backward) {\n        if (item.$index < index && fixRight) {\n          shift = -length;\n        } else if (item.$index >= index && !fixRight) {\n          shift = length;\n        }\n      } else if (direction === Direction.forward) {\n        if (item.$index <= index && fixRight) {\n          shift = -length;\n        } else if (item.$index > index && !fixRight) {\n          shift = length;\n        }\n      }\n      if (shift) {\n        item.changeIndex(item.$index + shift);\n      }\n      set(item);\n    });\n    if (this.saveData) { // persist data with no sizes\n      toInsert.forEach((data, i) => {\n        const $index = index + i - (fixRight ? length : 0) + (direction === Direction.forward ? 1 : 0);\n        const item = new ItemCache<Data>({ $index, data }, this.saveData);\n        set(item);\n      });\n    }\n    this.items = items;\n    this.minIndex = min;\n    this.maxIndex = max;\n  }\n\n  /**\n   * Removes items from Set, shifts $indexes of items that remain.\n   * Replaces current Set with a new one with new regular $indexes.\n   * Maintains min/max indexes and default item size.\n   *\n   * @param {number[]} toRemove List of indexes to be removed.\n   * @param {boolean} fixRight Defines indexes shifting strategy.\n   * If false, indexes that are greater than the removed ones will be decreased.\n   * If true, indexes that are less than than the removed ones will be increased.\n   */\n  removeItems(toRemove: number[], fixRight: boolean): void {\n    const items = new Map<number, ItemCache<Data>>();\n    let min = Infinity, max = -Infinity;\n    this.items.forEach(item => {\n      if (toRemove.some(index => index === item.$index)) {\n        if (item.size) {\n          this.defaultSize.setRemoved(item.size);\n        }\n        return;\n      }\n      const diff = fixRight\n        ? toRemove.reduce((acc, index) => acc + (item.$index < index ? 1 : 0), 0)\n        : toRemove.reduce((acc, index) => acc - (item.$index > index ? 1 : 0), 0);\n      item.changeIndex(item.$index + diff);\n      items.set(item.$index, item);\n      min = item.$index < min ? item.$index : min;\n      max = item.$index > max ? item.$index : max;\n    });\n    this.items = items;\n    this.minIndex = min;\n    this.maxIndex = max;\n  }\n\n  /**\n   * Destructively updates Set based on subset (before-after) changes.\n   * Replaces current Set with a new one with new regular $indexes.\n   * Maintains min/max indexes. Maintains default item size on remove only.\n   *\n   * @param {ItemUpdate[]} before Initial subset of items to be replaced by \"after\".\n   * Each element is an object with { $index, size, toRemove } props. Must be $index-incremental.\n   * Items to be removed must have toRemove flag: before[].toRemove = true.\n   * @param {Item<Data>[]} after Transformed subset that replaces \"before\". Must be $index-incremental.\n   * Must contain at least 1 $index from \"before\" or be empty.\n   * @param {boolean} fixRight This is to fix right indexes during subset collapsing. Acts only if \"after\" is empty.\n   */\n  updateSubset(before: ItemUpdate[], after: Item<Data>[], fixRight?: boolean): void {\n    if (!this.size || !before.length) {\n      return;\n    }\n    const minB = before[0].$index, maxB = before[before.length - 1].$index;\n    let leftDiff: number, rightDiff: number;\n    if (after.length) {\n      const minA = after[0].$index, maxA = after[after.length - 1].$index;\n      leftDiff = minA - minB;\n      rightDiff = maxA - maxB;\n    } else {\n      leftDiff = fixRight ? maxB - minB + 1 : 0;\n      rightDiff = fixRight ? 0 : minB - maxB - 1;\n    }\n    const items = new Map<number, ItemCache<Data>>();\n    this.items.forEach(item => {\n      if (item.$index < minB) { // items to the left of the subset\n        item.changeIndex(item.$index + leftDiff);\n        items.set(item.$index, item);\n        return;\n      } else if (item.$index > maxB) { // items to the right of the subset\n        item.changeIndex(item.$index + rightDiff);\n        items.set(item.$index, item);\n        return;\n      }\n    });\n    after.forEach(item => // subset items\n      items.set(item.$index, new ItemCache<Data>(item, this.saveData))\n    );\n    before // to maintain default size on remove\n      .filter(item => item.toRemove)\n      .forEach(item => this.defaultSize.setRemoved(item.size));\n    this.minIndex += leftDiff;\n    this.maxIndex += rightDiff;\n    this.items = items;\n  }\n\n  /**\n   * Shifts all indexes by some value.\n   * Replaces current Set with a new one with new regular $indexes.\n   * Maintains min/max indexes.\n   *\n   * @param {number} delta A shift value.\n   */\n  shiftIndexes(delta: number): void {\n    const items = new Map<number, ItemCache<Data>>();\n    let min = Infinity, max = -Infinity;\n    this.items.forEach(item => {\n      item.changeIndex(item.$index + delta);\n      items.set(item.$index, item);\n      min = item.$index < min ? item.$index : min;\n      max = item.$index > max ? item.$index : max;\n    });\n    this.items = items;\n    this.minIndex = min;\n    this.maxIndex = max;\n  }\n}\n","import { Buffer } from '../buffer';\nimport { Logger } from '../logger';\nimport { Direction } from '../../inputs/index';\nimport { ItemsPredicate } from '../../interfaces/index';\n\nexport class CheckBufferCall<Data> {\n  private context: Buffer<Data>;\n  private logger: Logger;\n\n  constructor(context: Buffer<Data>, logger: Logger) {\n    this.context = context;\n    this.logger = logger;\n  }\n\n  fillEmpty(items: Data[], before?: number, after?: number): boolean {\n    if (!items.length) {\n      this.logger.log('no items to fill the buffer; empty list');\n      return false;\n    }\n    if (!Number.isInteger(before) && !Number.isInteger(after)) {\n      this.logger.log('no items to fill the buffer; wrong indexes');\n      return false;\n    }\n    this.logger.log(() => `going to fill the buffer with ${items.length} item(s)`);\n    return true;\n  }\n\n  insertInBuffer(predicate?: ItemsPredicate, before?: number, after?: number): number {\n    const index = Number.isInteger(before) ? before : (Number.isInteger(after) ? after : NaN);\n    const found = this.context.items.find(item =>\n      (predicate && predicate(item.get())) ||\n      (Number.isInteger(index) && index === item.$index)\n    );\n    if (!found) {\n      this.logger.log('no items to insert in buffer; empty predicate\\'s result');\n      return NaN;\n    }\n    return found.$index;\n  }\n\n  insertVirtual(items: Data[], index: number, direction: Direction): boolean {\n    if (!items.length) {\n      this.logger.log('no items to insert virtually; empty list');\n      return false;\n    }\n    const { firstIndex, lastIndex, finiteAbsMinIndex, finiteAbsMaxIndex } = this.context;\n    if (index < finiteAbsMinIndex || index > finiteAbsMaxIndex) {\n      this.logger.log(() =>\n        'no items to insert virtually; ' +\n        `selected index (${index}) does not match virtual area [${finiteAbsMinIndex}..${finiteAbsMaxIndex}]`\n      );\n      return false;\n    }\n    const before = direction === Direction.backward;\n    if (!(index < firstIndex + (before ? 1 : 0) || index > lastIndex - (before ? 0 : 1))) {\n      this.logger.log(() =>\n        `no items to insert virtually; selected index (${index}) belongs Buffer [${firstIndex}..${lastIndex}]`\n      );\n      return false;\n    }\n    this.logger.log(() => `going to insert ${items.length} item(s) virtually`);\n    return true;\n  }\n\n}\n","import { Cache } from './buffer/cache';\nimport { CheckBufferCall } from './buffer/checkCall';\nimport { Item } from './item';\nimport { Settings } from './settings';\nimport { Logger } from './logger';\nimport { Reactive } from './reactive';\nimport { Direction } from '../inputs/index';\nimport { OnDataChanged, BufferUpdater, ItemsPredicate } from '../interfaces/index';\n\nexport class Buffer<Data> {\n\n  private _items: Item<Data>[] = [];\n  private _absMinIndex: number;\n  private _absMaxIndex: number;\n  bof: Reactive<boolean>;\n  eof: Reactive<boolean>;\n\n  changeItems: OnDataChanged<Data>;\n  minIndexUser: number;\n  maxIndexUser: number;\n  startIndexUser: number;\n  startIndex: number;\n\n  private pristine: boolean;\n  private cache: Cache<Data>;\n  private checkCall: CheckBufferCall<Data>;\n  private readonly logger: Logger;\n\n  constructor(settings: Settings<Data>, onDataChanged: OnDataChanged<Data>, logger: Logger) {\n    this.logger = logger;\n    this.changeItems = onDataChanged;\n    this.bof = new Reactive<boolean>(false);\n    this.eof = new Reactive<boolean>(false);\n    this.cache = new Cache<Data>(settings, logger);\n    this.checkCall = new CheckBufferCall(this, logger);\n    this.startIndexUser = settings.startIndex;\n    this.minIndexUser = settings.minIndex;\n    this.maxIndexUser = settings.maxIndex;\n    this.reset(true);\n  }\n\n  dispose(): void {\n    this.bof.dispose();\n    this.eof.dispose();\n    this._items.forEach(item => item.dispose());\n    this._items = [];\n  }\n\n  reset(force: boolean, startIndex?: number): void {\n    this.items.forEach(item => item.hide());\n    this.pristine = true;\n    this.items = [];\n    this.cache.reset(force);\n    this.absMinIndex = this.minIndexUser;\n    this.absMaxIndex = this.maxIndexUser;\n    this.setCurrentStartIndex(startIndex);\n    this.bof.set(false);\n    this.eof.set(false);\n    this.pristine = false;\n  }\n\n  setCurrentStartIndex(newStartIndex?: unknown): void {\n    const min = this.minIndexUser;\n    const max = this.maxIndexUser;\n    const start = this.startIndexUser;\n    let index = Number(newStartIndex);\n    if (Number.isNaN(index)) {\n      this.logger.log(() => `fallback startIndex to settings.startIndex (${start})`);\n      index = start;\n    }\n    if (index < min) {\n      this.logger.log(() => `setting startIndex to settings.minIndex (${min}) because ${index} < ${min}`);\n      index = min;\n    }\n    if (index > max) {\n      this.logger.log(() => `setting startIndex to settings.maxIndex (${max}) because ${index} > ${max}`);\n      index = max;\n    }\n    this.startIndex = index;\n  }\n\n  set items(items: Item<Data>[]) {\n    this._items = items;\n    this.changeItems(items);\n    if (!this.pristine) {\n      this.checkBOF();\n      this.checkEOF();\n    }\n  }\n\n  get items(): Item<Data>[] {\n    return this._items;\n  }\n\n  set absMinIndex(value: number) {\n    if (this._absMinIndex !== value) {\n      this._absMinIndex = Number.isFinite(this._absMaxIndex) && value > this._absMaxIndex ? this._absMaxIndex : value;\n    }\n    if (!this.pristine) {\n      this.checkBOF();\n    }\n  }\n\n  get absMinIndex(): number {\n    return this._absMinIndex;\n  }\n\n  set absMaxIndex(value: number) {\n    if (this._absMaxIndex !== value) {\n      this._absMaxIndex = Number.isFinite(this._absMinIndex) && value < this._absMinIndex ? this._absMinIndex : value;\n    }\n    if (!this.pristine) {\n      this.checkEOF();\n    }\n  }\n\n  get absMaxIndex(): number {\n    return this._absMaxIndex;\n  }\n\n  private checkBOF() {\n    // since bof has no setter, need to call checkBOF() on items and absMinIndex change\n    const bof = this.items.length\n      ? (this.items[0].$index === this.absMinIndex)\n      : isFinite(this.absMinIndex);\n    this.bof.set(bof);\n  }\n\n  private checkEOF() {\n    // since eof has no setter, need to call checkEOF() on items and absMaxIndex change\n    const eof = this.items.length\n      ? (this.items[this.items.length - 1].$index === this.absMaxIndex)\n      : isFinite(this.absMaxIndex);\n    this.eof.set(eof);\n  }\n\n  get size(): number {\n    return this._items.length;\n  }\n\n  get cacheSize(): number {\n    return this.cache.size;\n  }\n\n  get defaultSize(): number {\n    return this.cache.getDefaultSize();\n  }\n\n  get minIndex(): number {\n    return isFinite(this.cache.minIndex) ? this.cache.minIndex : this.startIndex;\n  }\n\n  get maxIndex(): number {\n    return isFinite(this.cache.maxIndex) ? this.cache.maxIndex : this.startIndex;\n  }\n\n  get firstIndex(): number {\n    return this.items.length ? this.items[0].$index : NaN;\n  }\n\n  get lastIndex(): number {\n    return this.items.length ? this.items[this.items.length - 1].$index : NaN;\n  }\n\n  get finiteAbsMinIndex(): number {\n    return isFinite(this.absMinIndex) ? this.absMinIndex : this.minIndex;\n  }\n\n  get finiteAbsMaxIndex(): number {\n    return isFinite(this.absMaxIndex) ? this.absMaxIndex : this.maxIndex;\n  }\n\n  get($index: number): Item<Data> | undefined {\n    return this.items.find(item => item.$index === $index);\n  }\n\n  setItems(items: Item<Data>[]): boolean {\n    if (!this.items.length) {\n      this.items = [...items];\n    } else if (this.items[0].$index > items[items.length - 1].$index) {\n      this.items = [...items, ...this.items];\n    } else if (items[0].$index > this.items[this.items.length - 1].$index) {\n      this.items = [...this.items, ...items];\n    } else {\n      return false;\n    }\n    return true;\n  }\n\n  clip(): void {\n    this.items = this.items.filter(({ toRemove }) => !toRemove);\n  }\n\n  getIndexToInsert(predicate?: ItemsPredicate, before?: number, after?: number): number {\n    return this.checkCall.insertInBuffer(predicate, before, after);\n  }\n\n  private shiftExtremum(amount: number, fixRight: boolean) {\n    if (!fixRight) {\n      this.absMaxIndex += amount;\n    } else {\n      this.absMinIndex -= amount;\n      this.startIndex -= amount;\n    }\n    if (this.startIndex > this.absMaxIndex) {\n      this.startIndex = this.absMaxIndex;\n    } else if (this.startIndex < this.absMinIndex) {\n      this.startIndex = this.absMinIndex;\n    }\n  }\n\n  insertVirtually(items: Data[], index: number, direction: Direction, fixRight: boolean): boolean {\n    if (!this.checkCall.insertVirtual(items, index, direction)) {\n      return false;\n    }\n    let shift = 0;\n    if (index <= this.firstIndex && !fixRight) {\n      shift = items.length;\n    } else if (index >= this.lastIndex && fixRight) {\n      shift = -items.length;\n    }\n    if (shift) {\n      this.items.forEach(item => item.updateIndex(item.$index + shift));\n      this.cache.insertItems(items, index, direction, fixRight);\n      this.items = [...this.items];\n    }\n    this.shiftExtremum(items.length, fixRight);\n    return true;\n  }\n\n  removeVirtually(indexes: number[], fixRight: boolean): void {\n    const length = this.items.length;\n    let shifted = false;\n    for (\n      let i = fixRight ? length - 1 : 0;\n      fixRight ? i >= 0 : i < length;\n      fixRight ? i-- : i++\n    ) {\n      const item = this.items[i];\n      const diff = indexes.reduce((acc, index) => acc + (fixRight\n        ? (item.$index < index ? 1 : 0)\n        : (item.$index > index ? -1 : 0)\n      ), 0);\n      shifted = shifted || !!diff;\n      item.updateIndex(item.$index + diff);\n    }\n    this.shiftExtremum(-indexes.length, fixRight);\n    if (shifted) {\n      this.items = [...this.items];\n    }\n    this.cache.removeItems(indexes, fixRight);\n  }\n\n  fillEmpty(\n    items: Data[], beforeIndex: number | undefined, afterIndex: number | undefined, fixRight: boolean,\n    generator: (index: number, data: Data) => Item<Data>,\n  ): boolean {\n    if (!this.checkCall.fillEmpty(items, beforeIndex, afterIndex)) {\n      return false;\n    }\n    const before = Number.isInteger(beforeIndex);\n    const index = (before ? beforeIndex : afterIndex) as number;\n    const shift = (fixRight ? items.length : (before ? 1 : 0));\n    this.items = items.map((data, i) =>\n      generator(index + i + (!before ? 1 : 0) - shift, data)\n    );\n    this._absMinIndex = this.items[0].$index;\n    this._absMaxIndex = this.items[this.size - 1].$index;\n    if (this.startIndex <= this.absMinIndex) {\n      this.startIndex = this.absMinIndex;\n    } else if (this.startIndex > this.absMaxIndex) {\n      this.startIndex = this.absMaxIndex;\n    }\n    return true;\n  }\n\n  updateItems(\n    predicate: BufferUpdater<Data>,\n    generator: (index: number, data: Data) => Item<Data>,\n    indexToTrack: number,\n    fixRight: boolean\n  ): { trackedIndex: number, toRemove: Item<Data>[] } {\n    if (!this.size || Number.isNaN(this.firstIndex)) {\n      return { trackedIndex: NaN, toRemove: [] };\n    }\n    let trackedIndex = indexToTrack;\n    let index = fixRight ? this.lastIndex : this.firstIndex;\n    const items: Item<Data>[] = [];\n    const diff = fixRight ? -1 : 1;\n    const limit = this.size - 1;\n    const beforeMap = new Map<number, Item>(); // need to persist original $indexes\n    const updateArray = Array.prototype[fixRight ? 'unshift' : 'push'];\n\n    for (let i = fixRight ? limit : 0; fixRight ? i >= 0 : i <= limit; i += diff) {\n      const item = this.items[i];\n      beforeMap.set(item.$index, item);\n      const result = predicate(item);\n\n      // if predicate result is falsy or empty array -> delete\n      if (!result || (Array.isArray(result) && !result.length)) {\n        item.toRemove = true;\n        trackedIndex += item.$index >= indexToTrack ? (fixRight ? 1 : 0) : (fixRight ? 0 : -1);\n        this.shiftExtremum(-1, fixRight);\n        continue;\n      }\n\n      // if predicate result is truthy but not array -> leave\n      if (!Array.isArray(result)) {\n        item.updateIndex(index);\n        updateArray.call(items, item);\n        index += diff;\n        continue;\n      }\n\n      // if predicate result is non-empty array -> insert/replace\n      if (item.$index < indexToTrack) {\n        trackedIndex += fixRight ? 0 : result.length - 1;\n      } else if (item.$index > indexToTrack) {\n        trackedIndex += fixRight ? 1 - result.length : 0;\n      }\n      let toRemove = true;\n      const newItems: Item<Data>[] = [];\n      (fixRight ? [...result].reverse() : result).forEach((data, i) => {\n        let newItem: Item<Data>;\n        if (item.data === data) {\n          if (indexToTrack === item.$index) {\n            trackedIndex = index + i * diff;\n          }\n          item.updateIndex(index + i * diff);\n          newItem = item;\n          toRemove = false; // insert case\n        } else {\n          newItem = generator(index + i * diff, data);\n          newItem.toInsert = true;\n        }\n        updateArray.call(newItems, newItem);\n      });\n      item.toRemove = toRemove;\n      updateArray.call(items, ...newItems);\n      index += diff * result.length;\n      if (result.length > 1) {\n        this.shiftExtremum(result.length - 1, fixRight);\n      }\n    }\n\n    const toRemove = this.items.filter(item => item.toRemove);\n    const itemsBefore = Array.from(beforeMap)\n      .map(([$index, { size, toRemove }]) => ({ $index, size, toRemove }))\n      .sort((a, b) => a.$index - b.$index);\n    this.items = items;\n    this.cache.updateSubset(itemsBefore, items, fixRight);\n\n    if (this.finiteAbsMinIndex === this.finiteAbsMaxIndex) {\n      trackedIndex = NaN;\n    } else if (trackedIndex > this.finiteAbsMaxIndex) {\n      trackedIndex = this.finiteAbsMaxIndex;\n    } else if (trackedIndex < this.finiteAbsMinIndex) {\n      trackedIndex = this.finiteAbsMinIndex;\n    }\n    return { trackedIndex, toRemove };\n  }\n\n  cacheItem(item: Item<Data>): void {\n    this.cache.add(item);\n  }\n\n  getFirstVisibleItemIndex(): number {\n    const length = this.items.length;\n    for (let i = 0; i < length; i++) {\n      if (!this.items[i].invisible) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  getLastVisibleItemIndex(): number {\n    for (let i = this.items.length - 1; i >= 0; i--) {\n      if (!this.items[i].invisible) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  getFirstVisibleItem(): Item<Data> | undefined {\n    const index = this.getFirstVisibleItemIndex();\n    if (index >= 0) {\n      return this.items[index];\n    }\n  }\n\n  getLastVisibleItem(): Item<Data> | undefined {\n    const index = this.getLastVisibleItemIndex();\n    if (index >= 0) {\n      return this.items[index];\n    }\n  }\n\n  getEdgeVisibleItem(direction: Direction, opposite?: boolean): Item<Data> | undefined {\n    return direction === (!opposite ? Direction.forward : Direction.backward) ?\n      this.getLastVisibleItem() : this.getFirstVisibleItem();\n  }\n\n  getVisibleItemsCount(): number {\n    return this.items.reduce((acc: number, item) => acc + (item.invisible ? 0 : 1), 0);\n  }\n\n  getSizeByIndex(index: number): number {\n    return this.cache.getSizeByIndex(index);\n  }\n\n  checkDefaultSize(): boolean {\n    return this.cache.recalculateDefaultSize();\n  }\n\n}\n","import { ProcessName } from '../../interfaces/index';\nimport { Reactive } from '../reactive';\n\nclass InnerLoopModel {\n  total: number;\n  count: number;\n  isInitial: boolean;\n  busy: Reactive<boolean>;\n\n  get first(): boolean {\n    return this.count === 0;\n  }\n\n  constructor(total: number) {\n    this.total = total;\n    this.isInitial = false;\n    this.busy = new Reactive<boolean>(false);\n  }\n\n  done() {\n    this.isInitial = false;\n    this.count++;\n    this.total++;\n    this.busy.set(false);\n  }\n\n  start() {\n    this.busy.set(true);\n  }\n\n  dispose() {\n    this.busy.dispose();\n  }\n}\n\nexport class WorkflowCycleModel {\n  instanceIndex: number;\n  count: number;\n  isInitial: boolean;\n  initiator: ProcessName;\n  innerLoop: InnerLoopModel;\n  interrupter: ProcessName | null;\n  busy: Reactive<boolean>;\n\n  get loopId(): string {\n    return `${this.instanceIndex}-${this.count}-${this.innerLoop.total}`;\n  }\n\n  get loopIdNext(): string {\n    return `${this.instanceIndex}-${this.count}-${this.innerLoop.total + 1}`;\n  }\n\n  constructor(instanceIndex: number, cycle?: WorkflowCycleModel) {\n    const cycleCount = cycle ? cycle.count : 1;\n    const loopCount = cycle ? cycle.innerLoop.count : 0;\n\n    this.instanceIndex = instanceIndex;\n    this.innerLoop = new InnerLoopModel(loopCount);\n    this.interrupter = null;\n    this.busy = new Reactive<boolean>(false);\n    this.end(cycleCount);\n  }\n\n  start(isInitial: boolean, initiator: ProcessName): void {\n    this.isInitial = isInitial;\n    this.initiator = initiator;\n    this.innerLoop.isInitial = isInitial;\n    this.innerLoop.count = 0;\n    this.interrupter = null;\n    this.busy.set(true);\n  }\n\n  end(count: number): void {\n    this.count = count;\n    this.isInitial = false;\n    this.busy.set(false);\n  }\n\n  dispose(forever?: boolean): void {\n    if (forever) {\n      // otherwise the value will be persisted during re-instantiation\n      this.busy.dispose();\n    }\n    this.innerLoop.dispose();\n  }\n}\n","import { Item } from '../item';\nimport { Direction } from '../../inputs/index';\n\nclass Positions {\n  startDelta: number;\n  before: number;\n  relative: number;\n  start: number;\n  end: number;\n\n  constructor() {\n    this.reset();\n  }\n\n  reset() {\n    this.startDelta = 0;\n    this.before = 0;\n  }\n}\n\nclass First {\n  index: number;\n  indexBuffer: number;\n  position: number;\n\n  constructor() {\n    this.reset();\n  }\n\n  reset() {\n    this.index = NaN;\n    this.indexBuffer = NaN;\n    this.position = NaN;\n  }\n}\n\nclass Last {\n  index: number;\n  indexBuffer: number;\n\n  constructor() {\n    this.reset();\n  }\n\n  reset() {\n    this.index = NaN;\n    this.indexBuffer = NaN;\n  }\n}\n\nclass FirstVisible {\n  index: number;\n  delta: number;\n\n  constructor() {\n    this.reset();\n  }\n\n  reset() {\n    this.index = NaN;\n    this.delta = 0;\n  }\n}\n\nexport class FetchModel {\n  private readonly directionPriority: Direction;\n  private _newItemsData: unknown[] | null; // there are public setter and getter\n\n  items: Item[];\n  positions: Positions;\n  first: First;\n  last: Last;\n  hasAnotherPack: boolean;\n  callCount: number;\n  minIndex: number;\n  firstVisible: FirstVisible;\n  direction: Direction | null;\n  cancel: (() => void) | null;\n\n  simulate: boolean;\n  isCheck: boolean;\n  doRemove: boolean;\n\n  constructor(directionPriority: Direction) {\n    this.directionPriority = directionPriority;\n    this.callCount = 0;\n    this.positions = new Positions();\n    this.first = new First();\n    this.last = new Last();\n    this.firstVisible = new FirstVisible();\n    this.reset();\n  }\n\n  reset(): void {\n    this._newItemsData = null;\n    this.items = [];\n    this.positions.reset();\n    this.first.reset();\n    this.last.reset();\n    this.firstVisible.reset();\n    this.hasAnotherPack = false;\n    this.direction = null;\n    this.cancel = null;\n    this.simulate = false;\n    this.isCheck = false;\n    this.doRemove = false;\n  }\n\n  get newItemsData(): unknown[] | null {\n    return this._newItemsData;\n  }\n\n  set newItemsData(items: unknown[] | null) {\n    this._newItemsData = items;\n    if (items && items.length) {\n      this.callCount++;\n    }\n  }\n\n  get shouldFetch(): boolean {\n    return !!this.count;\n  }\n\n  get hasNewItems(): boolean {\n    return !!((this._newItemsData && this._newItemsData.length));\n  }\n\n  get index(): number {\n    return this.first.index;\n  }\n\n  get count(): number {\n    return !isNaN(this.first.index) && !isNaN(this.last.index) ? this.last.index - this.first.index + 1 : 0;\n  }\n\n  shouldCheckPreSizeExpectation(lastBufferedIndex: number): boolean {\n    if (this.directionPriority === Direction.backward) {\n      return false;\n    }\n    const lastFetched = this.items[this.items.length - 1];\n    return lastFetched && lastFetched.$index < lastBufferedIndex;\n  }\n\n  startSimulate(items: Item[]): void {\n    this.simulate = true;\n    this._newItemsData = items.map(item => item.data);\n    this.items = items;\n    this.hasAnotherPack = false;\n  }\n\n  stopSimulate(): void {\n    this.simulate = false;\n    this.isCheck = false;\n    this.doRemove = false;\n  }\n\n  fill(items: Item[], start: number): void {\n    this.startSimulate(items);\n    this.first.index = items[0].$index;\n    this.last.index = items[items.length - 1].$index;\n    this.direction = Direction.forward;\n    this.firstVisible.index = start;\n    this.firstVisible.delta = 0;\n  }\n\n  check(items: Item[]): void {\n    this.startSimulate(items);\n    this.last.index = items[0].$index;\n    this.first.index = items[items.length - 1].$index;\n    this.isCheck = true;\n  }\n\n  update(index: number, delta: number, items: Item[], itemsToRemove: Item[]): void {\n    this.startSimulate(items);\n    this.firstVisible.index = index;\n    this.firstVisible.delta = delta;\n    this.doRemove = itemsToRemove.length > 0;\n  }\n}\n","export class ClipModel {\n  doClip: boolean;\n  callCount: number;\n  forceForward: boolean;\n  forceBackward: boolean;\n\n  get force(): boolean {\n    return this.forceForward || this.forceBackward;\n  }\n\n  constructor() {\n    this.callCount = 0;\n    this.reset();\n  }\n\n  reset(force?: boolean): void {\n    this.doClip = false;\n    if (!force) {\n      this.forceForward = false;\n      this.forceBackward = false;\n    }\n  }\n\n}\n","export class RenderModel {\n  sizeBefore: number;\n  sizeAfter: number;\n  positionBefore: number;\n  cancel: (() => void) | null;\n\n  get noSize(): boolean {\n    return this.sizeBefore === this.sizeAfter;\n  }\n\n  constructor() {\n    this.reset();\n  }\n\n  reset(): void {\n    this.sizeBefore = 0;\n    this.sizeAfter = 0;\n    this.positionBefore = 0;\n    this.cancel = null;\n  }\n}\n","import { ScrollEventData as IScrollEventData } from '../../interfaces/index';\n\nexport class ScrollModel {\n  previous: IScrollEventData | null;\n  current: IScrollEventData | null;\n\n  scrollTimer: ReturnType<typeof setTimeout> | null;\n\n  syntheticPosition: number | null;\n  syntheticFulfill: boolean;\n  cancelAnimation: (() => void) | null;\n  positionBeforeAsync: number | null;\n  positionBeforeAdjust: number | null;\n  positionAfterAdjust: number | null;\n\n  constructor() {\n    this.reset();\n  }\n\n  reset(): void {\n    this.previous = null;\n    this.current = null;\n    this.syntheticPosition = null;\n    this.syntheticFulfill = false;\n    this.positionBeforeAsync = null;\n    this.positionBeforeAdjust = null;\n    this.positionAfterAdjust = null;\n    this.stop();\n  }\n\n  stop(): void {\n    if (this.scrollTimer) {\n      clearTimeout(this.scrollTimer);\n      this.scrollTimer = null;\n    }\n    if (this.cancelAnimation) {\n      this.cancelAnimation();\n      this.cancelAnimation = null;\n    }\n  }\n\n  hasPositionChanged(position: number): boolean {\n    const before = this.positionBeforeAdjust;\n    const after = this.positionAfterAdjust;\n    return before === null || before !== position || after === null || after !== position;\n  }\n}\n","import { Settings } from './settings';\r\nimport { WorkflowCycleModel } from './state/cycle';\r\nimport { FetchModel } from './state/fetch';\r\nimport { ClipModel } from './state/clip';\r\nimport { RenderModel } from './state/render';\r\nimport { ScrollModel } from './state/scroll';\r\nimport { State as IState, IPackages, ProcessName } from '../interfaces/index';\r\n\r\nexport class State implements IState {\r\n\r\n  readonly packageInfo: IPackages;\r\n  private settings: Settings;\r\n  initTime: number;\r\n\r\n  cycle: WorkflowCycleModel;\r\n  fetch: FetchModel;\r\n  clip: ClipModel;\r\n  render: RenderModel;\r\n  scroll: ScrollModel;\r\n\r\n  get time(): number {\r\n    return Number(new Date()) - this.initTime;\r\n  }\r\n\r\n  constructor(packageInfo: IPackages, settings: Settings, state?: IState) {\r\n    this.packageInfo = packageInfo;\r\n    this.settings = settings;\r\n    this.initTime = Number(new Date());\r\n\r\n    this.cycle = new WorkflowCycleModel(this.settings.instanceIndex, state ? state.cycle : void 0);\r\n    this.fetch = new FetchModel(settings.directionPriority);\r\n    this.clip = new ClipModel();\r\n    this.render = new RenderModel();\r\n    this.scroll = new ScrollModel();\r\n  }\r\n\r\n  startWorkflowCycle(isInitial: boolean, initiator: ProcessName): void {\r\n    this.cycle.start(isInitial, initiator);\r\n  }\r\n\r\n  endWorkflowCycle(count: number): void {\r\n    this.cycle.end(count);\r\n  }\r\n\r\n  startInnerLoop(): { process?: ProcessName, doRender?: boolean } {\r\n    const { cycle, scroll: scroll, fetch, render, clip } = this;\r\n\r\n    cycle.innerLoop.start();\r\n    scroll.positionBeforeAsync = null;\r\n\r\n    if (!fetch.simulate) {\r\n      fetch.reset();\r\n    }\r\n    clip.reset(clip.force);\r\n    render.reset();\r\n\r\n    return {\r\n      ...(cycle.innerLoop.first ? {\r\n        process: cycle.initiator,\r\n        doRender: fetch.simulate && fetch.items.length > 0\r\n      } : {})\r\n    };\r\n  }\r\n\r\n  endInnerLoop(): void {\r\n    const { fetch, clip, render, cycle } = this;\r\n    fetch.stopSimulate();\r\n    clip.reset(true);\r\n    if (fetch.cancel) {\r\n      fetch.cancel();\r\n      fetch.cancel = null;\r\n    }\r\n    if (render.cancel) {\r\n      render.cancel();\r\n      render.cancel = null;\r\n    }\r\n    cycle.innerLoop.done();\r\n  }\r\n\r\n  dispose(): void {\r\n    this.scroll.stop();\r\n    this.cycle.dispose();\r\n    this.endInnerLoop();\r\n  }\r\n\r\n}\r\n","import { Logger } from './logger';\r\nimport { Buffer } from './buffer';\r\nimport { Reactive } from './reactive';\r\nimport {\r\n  AdapterPropName, AdapterPropType, getDefaultAdapterProps, methodPreResult, reactiveConfigStorage\r\n} from './adapter/props';\r\nimport { AdapterProcess, ProcessStatus } from '../processes/index';\r\nimport {\r\n  WorkflowGetter,\r\n  IAdapterProp,\r\n  AdapterMethodResult,\r\n  IAdapter,\r\n  ItemAdapter,\r\n  ItemsPredicate,\r\n  AdapterPrependOptions,\r\n  AdapterAppendOptions,\r\n  AdapterRemoveOptions,\r\n  AdapterClipOptions,\r\n  AdapterInsertOptions,\r\n  AdapterReplaceOptions,\r\n  AdapterUpdateOptions,\r\n  AdapterFixOptions,\r\n  ScrollerWorkflow,\r\n  IDatasourceOptional,\r\n  IPackages,\r\n  IBufferInfo,\r\n  State,\r\n  ProcessSubject,\r\n} from '../interfaces/index';\r\n\r\ntype MethodResolver = (...args: any[]) => Promise<AdapterMethodResult>;\r\n\r\nconst ADAPTER_PROPS_STUB = getDefaultAdapterProps();\r\n\r\nconst _has = (obj: unknown, prop: string): boolean =>\r\n  typeof obj === 'object' && obj !== null && Object.prototype.hasOwnProperty.call(obj, prop);\r\n\r\nconst convertAppendArgs = <Item>(prepend: boolean, options: unknown, eof?: boolean) => {\r\n  let result = options as AdapterAppendOptions<Item> & AdapterPrependOptions<Item>;\r\n  if (!_has(options, 'items')) {\r\n    const items = !Array.isArray(options) ? [options] : options;\r\n    result = prepend ? { items, bof: eof } : { items, eof: eof };\r\n  }\r\n  return result;\r\n};\r\n\r\nconst convertRemoveArgs = <Item>(options: AdapterRemoveOptions<Item> | ItemsPredicate<Item>) => {\r\n  if (!(_has(options, 'predicate') || _has(options, 'indexes'))) {\r\n    const predicate = options as ItemsPredicate<Item>;\r\n    options = { predicate };\r\n  }\r\n  return options;\r\n};\r\n\r\nexport class Adapter<Item = unknown> implements IAdapter<Item> {\r\n  private externalContext: IAdapter<Item>;\r\n  private logger: Logger;\r\n  private getWorkflow: WorkflowGetter<Item>;\r\n  private reloadCounter: number;\r\n  private source: { [key: string]: Reactive<unknown> } = {}; // for Reactive props\r\n  private box: { [key: string]: unknown } = {}; // for Scalars over Reactive props\r\n  private demand: { [key: string]: unknown } = {}; // for Scalars on demand\r\n  public wanted: { [key: string]: boolean } = {};\r\n\r\n  get workflow(): ScrollerWorkflow<Item> {\r\n    return this.getWorkflow();\r\n  }\r\n  get reloadCount(): number {\r\n    return this.reloadCounter;\r\n  }\r\n  get reloadId(): string {\r\n    return this.id + '.' + this.reloadCounter;\r\n  }\r\n\r\n  id: number;\r\n  mock: boolean;\r\n  augmented: boolean;\r\n  version: string;\r\n  init: boolean;\r\n  init$: Reactive<boolean>;\r\n  packageInfo: IPackages;\r\n  itemsCount: number;\r\n  bufferInfo: IBufferInfo;\r\n  isLoading: boolean;\r\n  isLoading$: Reactive<boolean>;\r\n  loopPending: boolean;\r\n  loopPending$: Reactive<boolean>;\r\n  firstVisible: ItemAdapter<Item>;\r\n  firstVisible$: Reactive<ItemAdapter<Item>>;\r\n  lastVisible: ItemAdapter<Item>;\r\n  lastVisible$: Reactive<ItemAdapter<Item>>;\r\n  bof: boolean;\r\n  bof$: Reactive<boolean>;\r\n  eof: boolean;\r\n  eof$: Reactive<boolean>;\r\n\r\n  private relax$: Reactive<AdapterMethodResult> | null;\r\n  private relaxRun: Promise<AdapterMethodResult> | null;\r\n\r\n  private getPromisifiedMethod(method: MethodResolver, defaultMethod: MethodResolver) {\r\n    return (...args: any[]): Promise<AdapterMethodResult> =>\r\n      this.relax$\r\n        ? new Promise(resolve => {\r\n          if (this.relax$) {\r\n            this.relax$.once(value => resolve(value));\r\n          }\r\n          method.apply(this, args);\r\n        })\r\n        : defaultMethod.apply(this, args);\r\n  }\r\n\r\n  constructor(context: IAdapter<Item> | null, getWorkflow: WorkflowGetter<Item>, logger: Logger) {\r\n    this.getWorkflow = getWorkflow;\r\n    this.logger = logger;\r\n    this.relax$ = null;\r\n    this.relaxRun = null;\r\n    this.reloadCounter = 0;\r\n\r\n    // public context (if exists) should provide access Reactive props configuration by id\r\n    const reactivePropsStore = context && reactiveConfigStorage.get(context.id) || {};\r\n\r\n    // make array of the original values from public context if present\r\n    const adapterProps = context\r\n      ? ADAPTER_PROPS_STUB.map(prop => {\r\n        let value = context[prop.name];\r\n        // if context is augmented, we need to replace external reactive props with inner ones\r\n        if (context.augmented) {\r\n          const reactiveProp = reactivePropsStore[prop.name];\r\n          if (reactiveProp) {\r\n            value = reactiveProp.default as Reactive<boolean>; // boolean doesn't matter here\r\n          }\r\n        }\r\n        return ({ ...prop, value });\r\n      })\r\n      : getDefaultAdapterProps();\r\n\r\n    // restore default reactive props if they were configured\r\n    Object.entries(reactivePropsStore).forEach(([key, value]) => {\r\n      const prop = adapterProps.find(({ name }) => name === key);\r\n      if (prop && value) {\r\n        prop.value = value.default;\r\n      }\r\n    });\r\n\r\n    // Scalar permanent props\r\n    adapterProps\r\n      .filter(({ type, permanent }) => type === AdapterPropType.Scalar && permanent)\r\n      .forEach(({ name, value }: IAdapterProp) =>\r\n        Object.defineProperty(this, name, {\r\n          configurable: true,\r\n          get: () => value\r\n        })\r\n      );\r\n\r\n    // Reactive props\r\n    // 1) store original values in \"source\" container, to avoid extra .get() calls on scalar twins set\r\n    // 2) \"wanted\" container is bound with scalars; get() updates it\r\n    adapterProps\r\n      .filter(prop => prop.type === AdapterPropType.Reactive)\r\n      .forEach(({ name, value }: IAdapterProp) => {\r\n        this.source[name] = value as Reactive<unknown>;\r\n        Object.defineProperty(this, name, {\r\n          configurable: true,\r\n          get: () => {\r\n            const scalarWanted = ADAPTER_PROPS_STUB.find(\r\n              ({ wanted, reactive }) => wanted && reactive === name\r\n            );\r\n            if (scalarWanted) {\r\n              this.wanted[scalarWanted.name] = true;\r\n            }\r\n            return this.source[name];\r\n          }\r\n        });\r\n      });\r\n\r\n    // Scalar props that have Reactive twins\r\n    // 1) scalars should use \"box\" container\r\n    // 2) \"wanted\" should be updated on get\r\n    // 3) reactive props (from \"source\") are triggered on set\r\n    adapterProps\r\n      .filter(prop => prop.type === AdapterPropType.Scalar && !!prop.reactive)\r\n      .forEach(({ name, value, reactive, wanted }: IAdapterProp) => {\r\n        if (wanted) {\r\n          this.wanted[name] = false;\r\n        }\r\n        this.box[name] = value;\r\n        Object.defineProperty(this, name, {\r\n          configurable: true,\r\n          set: (newValue: unknown) => {\r\n            if (newValue !== this.box[name]) {\r\n              this.box[name] = newValue;\r\n              this.source[reactive as AdapterPropName].set(newValue);\r\n              // need to emit new value through the configured reactive prop if present\r\n              const reactiveProp = reactivePropsStore[reactive as AdapterPropName];\r\n              if (reactiveProp) {\r\n                reactiveProp.emit(reactiveProp.source, newValue);\r\n              }\r\n            }\r\n          },\r\n          get: () => {\r\n            if (wanted) {\r\n              this.wanted[name] = true;\r\n            }\r\n            return this.box[name];\r\n          }\r\n        });\r\n      });\r\n\r\n    // Scalar props on-demand\r\n    // these scalars should use \"demand\" container\r\n    // setting defaults should be overridden on init()\r\n    adapterProps\r\n      .filter(prop => prop.type === AdapterPropType.Scalar && prop.onDemand)\r\n      .forEach(({ name, value }: IAdapterProp) => {\r\n        this.demand[name] = value;\r\n        Object.defineProperty(this, name, {\r\n          configurable: true,\r\n          get: () => this.demand[name]\r\n        });\r\n      });\r\n\r\n    if (!context) {\r\n      return;\r\n    }\r\n\r\n    // Adapter public context augmentation\r\n    adapterProps\r\n      .forEach(({ name, type, value: defaultValue, permanent }: IAdapterProp) => {\r\n        let value = (this as IAdapter)[name];\r\n        if (type === AdapterPropType.Function) {\r\n          value = (value as () => void).bind(this);\r\n        } else if (type === AdapterPropType.WorkflowRunner) {\r\n          value = this.getPromisifiedMethod(value as MethodResolver, defaultValue as MethodResolver);\r\n        } else if (type === AdapterPropType.Reactive && reactivePropsStore[name]) {\r\n          value = (context as IAdapter)[name];\r\n        } else if (name === AdapterPropName.augmented) {\r\n          value = true;\r\n        }\r\n        Object.defineProperty(context, name, {\r\n          configurable: true,\r\n          get: () => !permanent && type === AdapterPropType.Scalar\r\n            ? (this as IAdapter)[name] // non-permanent Scalars should be taken in runtime\r\n            : value // Reactive props and methods (Functions/WorkflowRunners) can be defined once\r\n        });\r\n      });\r\n\r\n    this.externalContext = context;\r\n  }\r\n\r\n  initialize(buffer: Buffer<Item>, state: State, logger: Logger, adapterRun$?: Reactive<ProcessSubject>): void {\r\n    // buffer\r\n    Object.defineProperty(this.demand, AdapterPropName.itemsCount, {\r\n      get: () => buffer.getVisibleItemsCount()\r\n    });\r\n    Object.defineProperty(this.demand, AdapterPropName.bufferInfo, {\r\n      get: (): IBufferInfo => ({\r\n        firstIndex: buffer.firstIndex,\r\n        lastIndex: buffer.lastIndex,\r\n        minIndex: buffer.minIndex,\r\n        maxIndex: buffer.maxIndex,\r\n        absMinIndex: buffer.absMinIndex,\r\n        absMaxIndex: buffer.absMaxIndex,\r\n        defaultSize: buffer.defaultSize,\r\n      })\r\n    });\r\n    this.bof = buffer.bof.get();\r\n    buffer.bof.on(bof => this.bof = bof);\r\n    this.eof = buffer.eof.get();\r\n    buffer.eof.on(eof => this.eof = eof);\r\n\r\n    // state\r\n    Object.defineProperty(this.demand, AdapterPropName.packageInfo, {\r\n      get: () => state.packageInfo\r\n    });\r\n    this.loopPending = state.cycle.innerLoop.busy.get();\r\n    state.cycle.innerLoop.busy.on(busy => this.loopPending = busy);\r\n    this.isLoading = state.cycle.busy.get();\r\n    state.cycle.busy.on(busy => this.isLoading = busy);\r\n\r\n    // logger\r\n    this.logger = logger;\r\n\r\n    // self-pending subscription; set up only on the very first init\r\n    if (adapterRun$) {\r\n      if (!this.relax$) {\r\n        this.relax$ = new Reactive();\r\n      }\r\n      const relax$ = this.relax$;\r\n      adapterRun$.on(({ status, payload }) => {\r\n        let unSubRelax = () => { };\r\n        if (status === ProcessStatus.start) {\r\n          unSubRelax = this.isLoading$.on(value => {\r\n            if (!value) {\r\n              unSubRelax();\r\n              relax$.set({ success: true, immediate: false, details: null });\r\n            }\r\n          });\r\n        } else if (status === ProcessStatus.done || status === ProcessStatus.error) {\r\n          unSubRelax();\r\n          relax$.set({\r\n            success: status !== ProcessStatus.error,\r\n            immediate: true,\r\n            details: status === ProcessStatus.error && payload ? String(payload.error) : null\r\n          });\r\n        }\r\n      });\r\n    }\r\n\r\n    // init\r\n    this.init = true;\r\n  }\r\n\r\n  dispose(): void {\r\n    if (this.relax$) {\r\n      this.relax$.dispose();\r\n    }\r\n    if (this.externalContext) {\r\n      this.resetContext();\r\n    }\r\n    Object.getOwnPropertyNames(this).forEach(prop => {\r\n      delete (this as Record<string, unknown>)[prop];\r\n    });\r\n  }\r\n\r\n  resetContext(): void {\r\n    const reactiveStore = reactiveConfigStorage.get(this.externalContext.id);\r\n    ADAPTER_PROPS_STUB\r\n      .forEach(({ type, permanent, name, value }) => {\r\n        // assign initial values to non-reactive non-permanent props\r\n        if (type !== AdapterPropType.Reactive && !permanent) {\r\n          Object.defineProperty(this.externalContext, name, {\r\n            configurable: true,\r\n            get: () => value\r\n          });\r\n        }\r\n        // reset reactive props\r\n        if (type === AdapterPropType.Reactive && reactiveStore) {\r\n          const property = reactiveStore[name];\r\n          if (property) {\r\n            property.default.reset();\r\n            property.emit(property.source, property.default.get());\r\n          }\r\n        }\r\n      });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  reset(options?: IDatasourceOptional): any {\r\n    this.reloadCounter++;\r\n    this.logger.logAdapterMethod('reset', options, ` of ${this.reloadId}`);\r\n    this.workflow.call({\r\n      process: AdapterProcess.reset,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  reload(options?: number | string): any {\r\n    this.reloadCounter++;\r\n    this.logger.logAdapterMethod('reload', options, ` of ${this.reloadId}`);\r\n    this.workflow.call({\r\n      process: AdapterProcess.reload,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  append(_options: AdapterAppendOptions<Item> | unknown, eof?: boolean): any {\r\n    const options = convertAppendArgs(false, _options, eof); // support old signature\r\n    this.logger.logAdapterMethod('append', [options.items, options.eof]);\r\n    this.workflow.call({\r\n      process: AdapterProcess.append,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  prepend(_options: AdapterPrependOptions<Item> | unknown, bof?: boolean): any {\r\n    const options = convertAppendArgs(true, _options, bof); // support old signature\r\n    this.logger.logAdapterMethod('prepend', [options.items, options.bof]);\r\n    this.workflow.call({\r\n      process: AdapterProcess.prepend,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  check(): any {\r\n    this.logger.logAdapterMethod('check');\r\n    this.workflow.call({\r\n      process: AdapterProcess.check,\r\n      status: ProcessStatus.start\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  remove(options: AdapterRemoveOptions<Item> | ItemsPredicate<Item>): any {\r\n    options = convertRemoveArgs(options); // support old signature\r\n    this.logger.logAdapterMethod('remove', options);\r\n    this.workflow.call({\r\n      process: AdapterProcess.remove,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  clip(options?: AdapterClipOptions): any {\r\n    this.logger.logAdapterMethod('clip', options);\r\n    this.workflow.call({\r\n      process: AdapterProcess.clip,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  insert(options: AdapterInsertOptions<Item>): any {\r\n    this.logger.logAdapterMethod('insert', options);\r\n    this.workflow.call({\r\n      process: AdapterProcess.insert,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  replace(options: AdapterReplaceOptions<Item>): any {\r\n    this.logger.logAdapterMethod('replace', options);\r\n    this.workflow.call({\r\n      process: AdapterProcess.replace,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  update(options: AdapterUpdateOptions<Item>): any {\r\n    this.logger.logAdapterMethod('update', options);\r\n    this.workflow.call({\r\n      process: AdapterProcess.update,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  fix(options: AdapterFixOptions<Item>): any {\r\n    this.logger.logAdapterMethod('fix', options);\r\n    this.workflow.call({\r\n      process: AdapterProcess.fix,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  relaxUnchained(callback: (() => void) | undefined, reloadId: string): Promise<AdapterMethodResult> {\r\n    const runCallback = () => typeof callback === 'function' && reloadId === this.reloadId && callback();\r\n    if (!this.isLoading) {\r\n      runCallback();\r\n    }\r\n    return new Promise<boolean>(resolve => {\r\n      if (!this.isLoading) {\r\n        resolve(true);\r\n        return;\r\n      }\r\n      this.isLoading$.once(() => {\r\n        runCallback();\r\n        resolve(false);\r\n      });\r\n    }).then(immediate => {\r\n      const success = reloadId === this.reloadId;\r\n      this.logger.log(() => !success ? `relax promise cancelled due to ${reloadId} != ${this.reloadId}` : void 0);\r\n      return {\r\n        immediate,\r\n        success,\r\n        details: !success ? 'Interrupted by reload or reset' : null\r\n      };\r\n    });\r\n  }\r\n\r\n  relax(callback?: () => void): Promise<AdapterMethodResult> {\r\n    const reloadId = this.reloadId;\r\n    this.logger.logAdapterMethod('relax', callback, ` of ${reloadId}`);\r\n    if (!this.init) {\r\n      return Promise.resolve(methodPreResult);\r\n    }\r\n    return this.relaxRun = this.relaxRun\r\n      ? this.relaxRun.then(() => this.relaxUnchained(callback, reloadId))\r\n      : this.relaxUnchained(callback, reloadId).then((result) => {\r\n        this.relaxRun = null;\r\n        return result;\r\n      });\r\n  }\r\n\r\n  showLog(): void {\r\n    this.logger.logAdapterMethod('showLog');\r\n    this.logger.logForce();\r\n  }\r\n}\r\n","import { DatasourceGeneric, makeDatasource } from './classes/datasource';\nimport { Settings } from './classes/settings';\nimport { Logger } from './classes/logger';\nimport { Routines } from './classes/domRoutines';\nimport { Viewport } from './classes/viewport';\nimport { Buffer } from './classes/buffer';\nimport { State } from './classes/state';\nimport { Adapter } from './classes/adapter';\nimport { Reactive } from './classes/reactive';\nimport { validate, DATASOURCE } from './inputs/index';\nimport core from './version';\nimport {\n  ScrollerWorkflow, IDatasource, IDatasourceConstructed, ScrollerParams, IPackages, ProcessSubject\n} from './interfaces/index';\n\nexport const INVALID_DATASOURCE_PREFIX = 'Invalid datasource:';\n\nlet instanceCount = 0;\n\nexport class Scroller<Data = unknown> {\n  public datasource: IDatasourceConstructed<Data>;\n  public workflow: ScrollerWorkflow<Data>;\n\n  public settings: Settings<Data>;\n  public logger: Logger;\n  public routines: Routines;\n  public viewport: Viewport;\n  public buffer: Buffer<Data>;\n  public state: State;\n  public adapter: Adapter<Data>;\n\n  constructor({\n    datasource, consumer, element, workflow, Routines: CustomRoutines, scroller\n  }: ScrollerParams<Data>) {\n    const { params: { get } } = validate(datasource, DATASOURCE);\n    if (!get.isValid) {\n      throw new Error(`${INVALID_DATASOURCE_PREFIX} ${get.errors[0]}`);\n    }\n\n    const packageInfo = scroller ? scroller.state.packageInfo : ({ consumer, core } as IPackages);\n    element = scroller ? scroller.routines.element : (element as HTMLElement);\n    workflow = scroller ? scroller.workflow : (workflow as ScrollerWorkflow<Data>);\n\n    this.workflow = workflow;\n    this.settings = new Settings<Data>(datasource.settings, datasource.devSettings, ++instanceCount);\n    this.logger = new Logger(this as Scroller, packageInfo, datasource.adapter);\n    this.routines = new Routines(element, this.settings, CustomRoutines);\n    this.state = new State(packageInfo, this.settings, scroller ? scroller.state : void 0);\n    this.buffer = new Buffer<Data>(this.settings, workflow.onDataChanged, this.logger);\n    this.viewport = new Viewport(this.settings, this.routines, this.state, this.logger);\n    this.logger.object('vscroll settings object', this.settings, true);\n\n    this.initDatasource(datasource, scroller);\n  }\n\n  initDatasource(datasource: IDatasource<Data>, scroller?: Scroller<Data>): void {\n    if (scroller) { // scroller re-instantiating case\n      this.datasource = datasource as IDatasourceConstructed<Data>;\n      this.adapter = scroller.adapter;\n      // todo: what about (this.settings.adapter !== scroller.setting.adapter) case?\n      return;\n    }\n    // scroller is being instantiated for the first time\n    const constructed = datasource instanceof DatasourceGeneric;\n    const mockAdapter = !constructed && !this.settings.adapter;\n    if (constructed) { // datasource is already instantiated\n      this.datasource = datasource as IDatasourceConstructed<Data>;\n    } else { // datasource as POJO\n      const DS = makeDatasource(() => ({ mock: mockAdapter }));\n      this.datasource = new DS<Data>(datasource);\n      if (this.settings.adapter) {\n        datasource.adapter = this.datasource.adapter;\n      }\n    }\n    const publicContext = !mockAdapter ? this.datasource.adapter : null;\n    this.adapter = new Adapter<Data>(publicContext, () => this.workflow, this.logger);\n  }\n\n  init(adapterRun$?: Reactive<ProcessSubject>): void {\n    this.viewport.reset(this.buffer.startIndex);\n    this.logger.stat('initialization');\n    this.adapter.initialize(this.buffer, this.state, this.logger, adapterRun$);\n  }\n\n  dispose(forever?: boolean): void {\n    if (forever) { // Adapter is not re-instantiated on reset\n      this.adapter.dispose();\n    }\n    this.buffer.dispose();\n    this.state.dispose();\n  }\n\n  finalize(): void {\n  }\n\n}\n","import { Scroller } from './scroller';\nimport { runStateMachine } from './workflow-transducer';\nimport { Reactive } from './classes/reactive';\nimport { Item } from './classes/item';\nimport { CommonProcess, ProcessStatus as Status, } from './processes/index';\nimport {\n  WorkflowParams,\n  ProcessName,\n  ProcessPayload,\n  ProcessClass,\n  ProcessSubject,\n  WorkflowError,\n  InterruptParams,\n  StateMachineMethods,\n  ScrollerWorkflow,\n} from './interfaces/index';\n\nexport class Workflow<ItemData = unknown> {\n\n  isInitialized: boolean;\n  initTimer: ReturnType<typeof setTimeout> | null;\n  adapterRun$: Reactive<ProcessSubject>;\n  cyclesDone: number;\n  interruptionCount: number;\n  errors: WorkflowError[];\n\n  private offScroll: () => void;\n  readonly propagateChanges: WorkflowParams<ItemData>['run'];\n  readonly stateMachineMethods: StateMachineMethods<ItemData>;\n\n  scroller: Scroller<ItemData>;\n\n  constructor({ element, datasource, consumer, run, Routines }: WorkflowParams<ItemData>) {\n    this.isInitialized = false;\n    this.initTimer = null;\n    this.adapterRun$ = new Reactive();\n    this.cyclesDone = 0;\n    this.interruptionCount = 0;\n    this.errors = [];\n    this.offScroll = () => null;\n    this.propagateChanges = run;\n    this.stateMachineMethods = {\n      run: this.runProcess(),\n      interrupt: this.interrupt.bind(this),\n      done: this.done.bind(this),\n      onError: this.onError.bind(this)\n    };\n\n    this.scroller = new Scroller<ItemData>({\n      element, datasource, consumer, workflow: this.getUpdater(), Routines\n    });\n\n    if (this.scroller.settings.initializeDelay) {\n      this.initTimer = setTimeout(() => {\n        this.initTimer = null;\n        this.init();\n      }, this.scroller.settings.initializeDelay);\n    } else {\n      this.init();\n    }\n  }\n\n  init(): void {\n    this.scroller.init(this.adapterRun$);\n    this.isInitialized = true;\n\n    // run the Workflow\n    this.callWorkflow({\n      process: CommonProcess.init,\n      status: Status.start\n    });\n\n    // set up scroll event listener\n    const { routines } = this.scroller;\n    const onScrollHandler: EventListener =\n      event => this.callWorkflow({\n        process: CommonProcess.scroll,\n        status: Status.start,\n        payload: { event }\n      });\n    this.offScroll = routines.onScroll(onScrollHandler);\n  }\n\n  changeItems(items: Item<ItemData>[]): void {\n    this.propagateChanges(items);\n  }\n\n  callWorkflow(processSubject: ProcessSubject): void {\n    if (!this.isInitialized) {\n      return;\n    }\n    const { process, status } = processSubject;\n    if (process && process.startsWith('adapter') && status !== Status.next) {\n      this.adapterRun$.set(processSubject);\n    }\n    this.process(processSubject);\n  }\n\n  getUpdater(): ScrollerWorkflow<ItemData> {\n    return {\n      call: this.callWorkflow.bind(this),\n      onDataChanged: this.changeItems.bind(this),\n    };\n  }\n\n  process(data: ProcessSubject): void {\n    const { status, process, payload } = data;\n    if (this.scroller.settings.logProcessRun) {\n      this.scroller.logger.log(() => [\n        '%cfire%c', ...['color: #cc7777;', 'color: #000000;'],\n        process, `\"${status}\"`, ...(payload !== void 0 ? [payload] : [])\n      ]);\n    }\n    this.scroller.logger.logProcess(data);\n\n    if (process === CommonProcess.end) {\n      this.scroller.finalize();\n    }\n    runStateMachine({\n      input: data,\n      methods: this.stateMachineMethods as StateMachineMethods<unknown>\n    });\n  }\n\n  runProcess() {\n    return ({ run, process, name }: ProcessClass) =>\n      (...args: any[]): void => {\n        if (this.scroller.settings.logProcessRun) {\n          this.scroller.logger.log(() => [\n            '%crun%c', ...['color: #333399;', 'color: #000000;'],\n            process || name, ...args\n          ]);\n        }\n        run(this.scroller as Scroller, ...args);\n      };\n  }\n\n  onError(process: ProcessName, payload?: ProcessPayload): void {\n    const message: string = payload && String(payload.error) || '';\n    const { time, cycle } = this.scroller.state;\n    this.errors.push({\n      process,\n      message,\n      time,\n      loop: cycle.loopIdNext\n    });\n    this.scroller.logger.logError(message);\n  }\n\n  interrupt({ process, finalize, datasource }: InterruptParams<ItemData>): void {\n    if (finalize) {\n      const { workflow, logger } = this.scroller;\n      // we are going to create a new reference for the scroller.workflow object\n      // calling the old version of the scroller.workflow by any outstanding async processes will be skipped\n      workflow.call = (p: ProcessSubject) => // eslint-disable-line @typescript-eslint/no-unused-vars\n        logger.log('[skip wf call]');\n      workflow.call.interrupted = true;\n      this.scroller.workflow = this.getUpdater();\n      this.interruptionCount++;\n      logger.log(() => `workflow had been interrupted by the ${process} process (${this.interruptionCount})`);\n    }\n    if (datasource) { // Scroller re-initialization case\n      this.scroller.adapter.relax(() => {\n        this.scroller.logger.log('new Scroller instantiation');\n        const scroller = new Scroller<ItemData>({ datasource, scroller: this.scroller });\n        this.scroller.dispose();\n        this.scroller = scroller;\n        this.scroller.init();\n      });\n    }\n  }\n\n  done(): void {\n    const { state, logger } = this.scroller;\n    this.cyclesDone++;\n    logger.logCycle(false);\n    state.endWorkflowCycle(this.cyclesDone + 1);\n    this.finalize();\n  }\n\n  dispose(): void {\n    if (this.initTimer) {\n      clearTimeout(this.initTimer);\n    }\n    this.offScroll();\n    this.adapterRun$.dispose();\n    this.scroller.dispose(true);\n    Object.getOwnPropertyNames(this).forEach(prop => {\n      delete (this as Record<string, unknown>)[prop];\n    });\n  }\n\n  finalize(): void {\n  }\n\n}\n","import {\n  CommonProcess,\n  AdapterProcess,\n  ProcessStatus as Status,\n  Init,\n  Scroll,\n  Reset,\n  Reload,\n  Append,\n  Check,\n  Remove,\n  UserClip,\n  Insert,\n  Replace,\n  Update,\n  Fix,\n  Start,\n  PreFetch,\n  Fetch,\n  PostFetch,\n  Render,\n  PreClip,\n  Clip,\n  Adjust,\n  End,\n} from './processes/index';\n\nimport { StateMachineParams } from './interfaces/index';\n\nexport const runStateMachine = ({\n  input: { process, status, payload = {} },\n  methods: { run, interrupt, done, onError }\n}: StateMachineParams): void => {\n  if (status === Status.error) {\n    onError(process, payload);\n    if (!process.startsWith('adapter')) {\n      run(End)(payload);\n    }\n    return;\n  }\n  const { options } = payload;\n  switch (process) {\n    case CommonProcess.init:\n      if (status === Status.start) { // App start\n        run(Init)(process);\n      }\n      if (status === Status.next) {\n        run(Start)();\n      }\n      break;\n    case CommonProcess.scroll:\n      if (status === Status.start) {\n        run(Scroll)(payload);\n      }\n      if (status === Status.next) {\n        run(Init)(process);\n      }\n      break;\n    case AdapterProcess.reset:\n    case AdapterProcess.reload:\n      if (status === Status.start) {\n        if (process === AdapterProcess.reset) {\n          run(Reset)(options);\n        } else {\n          run(Reload)(options);\n        }\n      }\n      if (status === Status.next) {\n        interrupt({ process, ...payload });\n        if (payload.finalize) {\n          run(End)();\n        } else {\n          run(Init)(process);\n        }\n      }\n      break;\n    case AdapterProcess.append:\n    case AdapterProcess.prepend:\n      if (status === Status.start) {\n        run(Append)({ process, options });\n      }\n      if (status === Status.next) {\n        run(Init)(process);\n      }\n      break;\n    case AdapterProcess.check:\n      if (status === Status.start) {\n        run(Check)();\n      }\n      if (status === Status.next) {\n        run(Init)(process);\n      }\n      break;\n    case AdapterProcess.remove:\n      if (status === Status.start) {\n        run(Remove)(options);\n      }\n      if (status === Status.next) {\n        run(Init)(process);\n      }\n      break;\n    case AdapterProcess.clip:\n      if (status === Status.start) {\n        run(UserClip)(options);\n      }\n      if (status === Status.next) {\n        run(Init)(process);\n      }\n      break;\n    case AdapterProcess.insert:\n      if (status === Status.start) {\n        run(Insert)(options);\n      }\n      if (status === Status.next) {\n        run(Init)(process);\n      }\n      break;\n    case AdapterProcess.replace:\n      if (status === Status.start) {\n        run(Replace)(options);\n      }\n      if (status === Status.next) {\n        run(Init)(process);\n      }\n      break;\n    case AdapterProcess.update:\n      if (status === Status.start) {\n        run(Update)(options);\n      }\n      if (status === Status.next) {\n        run(Init)(process);\n      }\n      break;\n    case AdapterProcess.fix:\n      if (status === Status.start) {\n        run(Fix)(options);\n      }\n      if (status === Status.next) {\n        run(Init)(process);\n      }\n      break;\n    case CommonProcess.start:\n      switch (payload.process) {\n        case AdapterProcess.append:\n        case AdapterProcess.insert:\n        case AdapterProcess.replace:\n        case AdapterProcess.update:\n          if (payload.doRender) {\n            run(Render)();\n          } else {\n            run(Adjust)();\n          }\n          break;\n        case AdapterProcess.check:\n          run(Render)();\n          break;\n        case AdapterProcess.remove:\n          run(Adjust)();\n          break;\n        default:\n          run(PreFetch)();\n      }\n      break;\n    case CommonProcess.preFetch:\n      if (status === Status.next) {\n        switch (payload.process) {\n          case AdapterProcess.clip:\n            run(PreClip)();\n            break;\n          default:\n            run(Fetch)();\n        }\n      }\n      if (status === Status.done) {\n        run(End)();\n      }\n      break;\n    case CommonProcess.fetch:\n      run(PostFetch)();\n      break;\n    case CommonProcess.postFetch:\n      if (status === Status.next) {\n        run(Render)();\n      }\n      if (status === Status.done) {\n        run(End)();\n      }\n      break;\n    case CommonProcess.render:\n      if (status === Status.next) {\n        switch (payload.process) {\n          case AdapterProcess.append:\n          case AdapterProcess.check:\n          case AdapterProcess.insert:\n          case AdapterProcess.replace:\n          case AdapterProcess.update:\n            run(Adjust)();\n            break;\n          default:\n            run(PreClip)();\n        }\n      }\n      if (status === Status.done) {\n        run(End)();\n      }\n      break;\n    case CommonProcess.preClip:\n      if (payload.doClip) {\n        run(Clip)();\n      } else {\n        run(Adjust)();\n      }\n      break;\n    case CommonProcess.clip:\n      run(Adjust)();\n      break;\n    case CommonProcess.adjust:\n      run(End)();\n      break;\n    case CommonProcess.end:\n      if (status === Status.next) {\n        switch (payload.process) {\n          case AdapterProcess.reset:\n          case AdapterProcess.reload:\n            done();\n            run(Init)(payload.process);\n            break;\n          default:\n            run(Start)();\n        }\n      }\n      if (status === Status.done) {\n        done();\n      }\n      break;\n  }\n};\n"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__extends","TypeError","String","__","this","constructor","create","__assign","assign","t","s","i","n","arguments","length","apply","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","__generator","body","f","y","g","_","label","sent","trys","ops","verb","Symbol","iterator","v","op","pop","push","__values","o","m","__read","r","ar","error","__spreadArray","to","from","pack","l","slice","concat","AdapterPropName","AdapterPropType","Direction","SizeStrategy","ValidatorType","Name","Type","noop","methodPreResult","noopWF","emptyPackageInfo","bufferInfoDefault","EMPTY_ITEM","getDefaultAdapterProps","reactiveConfigStorage","Map","instanceCount","mock","id","makeDatasource","getConfig","Datasource","DatasourceProps","getError","msg","args","getNumber","onNumber","onMoreOrEqual","limit","fallback","onFunction","onFunctionWithXToYArguments","onOneOf","tokens","must","context","onEnum","list","VALIDATORS","argsCount","validators","runValidator","current","validator","getDefault","prop","validateOne","name","validate","params","OBJECT","FUNC_WITH_X_AND_MORE_ARGUMENTS","Settings","DevSettings","DATASOURCE","get","settings","devSettings","NUMBER","INTEGER","INTEGER_UNLIMITED","MORE_OR_EQUAL","BOOLEAN","ELEMENT","FUNC","OR","ENUM","CommonProcess","AdapterProcess","ProcessStatus","MIN","throttle","initDelay","initWindowDelay","SETTINGS","DEV_SETTINGS","debug","immediateLog","logProcessRun","logTime","cacheData","cacheOnReload","dismissOverflowAnchor","directionPriority","AdapterNoParams","ITEM_LIST","FUNC_WITH_X_ARGUMENTS","FUNC_WITH_X_TO_Y_ARGUMENTS","ONE_OF_MUST","ONE_OF_CAN","AdapterReloadParams","RESET_METHOD_PARAMS","AdapterPrependParams","RELOAD_METHOD_PARAMS","reloadIndex","AdapterAppendParams","PREPEND_METHOD_PARAMS","items","bof","increase","AdapterRemoveParams","APPEND_METHOD_PARAMS","eof","decrease","AdapterClipParams","REMOVE_METHOD_PARAMS","predicate","indexes","AdapterInsertParams","CLIP_METHOD_PARAMS","backwardOnly","forwardOnly","AdapterReplaceParams","INSERT_METHOD_PARAMS","before","after","beforeIndex","afterIndex","AdapterUpdateParams","REPLACE_METHOD_PARAMS","fixRight","AdapterFixParams","UPDATE_METHOD_PARAMS","FIX_METHOD_PARAMS","scrollPosition","minIndex","maxIndex","updater","scrollToItem","scrollToItemOpt","AdapterMethods","ADAPTER_METHODS","BaseProcessFactory","process","BaseAdapterProcessFactory","initProcesses","init","reset","reload","state","workflow","scroll","log","position","time","datasource","viewport","$index","data","preSize","buffer","update","diff","insert","append","item","check","fetch","index","finiteAbsMinIndex","firstVisible","remove","clip","replace","FixParams","fix","start","positions","last","preFetch","postFetch","render","isInterrupted","adapter","end","size","adjust","preClip","logs","logAdapterMethod","window","horizontal","_items","newItem","toRemove","a","ADAPTER_PROPS_STUB","_has","obj","convertAppendArgs","prepend","options","source","box","demand","wanted","reactive","core","routines","status","input","payload","methods","scroller"],"sourceRoot":""}